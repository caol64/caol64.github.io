<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从PS2记忆卡中导出存档文件 | 路边的阿不</title><meta name=keywords content="Playstation2,Python"><meta name=description content="上一篇文章中我们解析了PS2存储卡的文件系统，这次直接实战，编写python代码导出指定的游戏存档。本篇文章完整代码可以访问：https:/"><meta name=author content="路边的阿不"><link rel=canonical href=https://babyno.top/posts/2023/09/exporting-file-from-ps2-memcard/><meta name=google-site-verification content="G-W1K6MS6C1Z"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://babyno.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://babyno.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://babyno.top/favicon-32x32.png><link rel=apple-touch-icon href=https://babyno.top/apple-touch-icon.png><link rel=mask-icon href=https://babyno.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-21338538-2","auto"),ga("send","pageview"))</script><meta property="og:title" content="从PS2记忆卡中导出存档文件"><meta property="og:description" content="上一篇文章中我们解析了PS2存储卡的文件系统，这次直接实战，编写python代码导出指定的游戏存档。本篇文章完整代码可以访问：https:/"><meta property="og:type" content="article"><meta property="og:url" content="https://babyno.top/posts/2023/09/exporting-file-from-ps2-memcard/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-29T17:49:16+00:00"><meta property="article:modified_time" content="2023-09-29T17:49:16+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="从PS2记忆卡中导出存档文件"><meta name=twitter:description content="上一篇文章中我们解析了PS2存储卡的文件系统，这次直接实战，编写python代码导出指定的游戏存档。本篇文章完整代码可以访问：https:/"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://babyno.top/posts/"},{"@type":"ListItem","position":2,"name":"从PS2记忆卡中导出存档文件","item":"https://babyno.top/posts/2023/09/exporting-file-from-ps2-memcard/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从PS2记忆卡中导出存档文件","name":"从PS2记忆卡中导出存档文件","description":"上一篇文章中我们解析了PS2存储卡的文件系统，这次直接实战，编写python代码导出指定的游戏存档。本篇文章完整代码可以访问：https:/","keywords":["Playstation2","Python"],"articleBody":"上一篇文章中我们解析了PS2存储卡的文件系统，这次直接实战，编写python代码导出指定的游戏存档。本篇文章完整代码可以访问：https://github.com/caol64/ps2mc-browser。\n01 解析SuperBlock SuperBlock结构如下，大小为340字节：\nstruct SuperBlock { char magic[28]; char version[12]; uint16 page_size; uint16 pages_per_cluster; uint16 pages_per_block; uint16 unknown; // ignore uint32 clusters_per_card; uint32 alloc_offset; uint32 alloc_end; uint32 rootdir_cluster; uint32 backup_block1; // ignore uint32 backup_block2; // ignore uint32 unknown[2]; // ignore uint32 ifc_list[32]; uint32 bad_block_list[32]; // ignore byte card_type; byte card_flags; byte unknown; // ignore byte unknown; // ignore }; 使用struct.unpack()解包：\nstruct.Struct(\"\u003c28s12sHHH2xLLLL4x4x8x128s128xbbxx\").unpack(byte_val) 得到page_size和pages_per_cluster。\n02 读取page和cluster 根据公式计算page和cluster大小：\nself.spare_size = (self.page_size // 128) * 4 # 备用区域字节数 self.raw_page_size = self.page_size + self.spare_size # 算上备用区域的page字节数 self.cluster_size = self.page_size * self.pages_per_cluster # 簇字节数 读取page和cluster，spare area里的内容是被舍弃掉的：\ndef read_page(self, n): # n为page编号 offset = self.raw_page_size * n return self.byte_val[offset: offset + self.page_size] def read_cluster(self, n): # n为cluster编号 page_index = n * self.pages_per_cluster byte_buffer = bytearray() for i in range(self.pages_per_cluster): byte_buffer += self.read_page(page_index + i) return bytes(byte_buffer) 03 构建FAT矩阵 从上一篇文章知道FAT矩阵的构建方式如下： def __build_fat_matrix(self): indirect_fat_matrix = self.__build_matrix(self.ifc_list) # 从ifc_list构建间接FAT indirect_fat_matrix = indirect_fat_matrix.reshape(indirect_fat_matrix.size) # 间接FAT是个一维数组 indirect_fat_matrix = [x for x in indirect_fat_matrix if x != Fat.UNALLOCATED] # 排除掉0xFFFFFFFF这种未分配的 fat_matrix = self.__build_matrix(indirect_fat_matrix) # 从间接FAT构建直接FAT return fat_matrix def __build_matrix(self, cluster_list): matrix = np.zeros((len(cluster_list), self.fat_per_cluster), np.uint32) # 初始化矩阵 for index, v in enumerate(cluster_list): # 遍历cluster cluster_value = self.read_cluster(v) # 读出每个cluster的256个FAT cluster_value_unpacked = np.frombuffer(cluster_value, np.uint32) for index0, v0 in enumerate(cluster_value_unpacked): matrix[index, index0] = v0 # 给矩阵赋值 return matrix def get_fat_value(self, n): # 给出簇编号n，找到其对应的FAT的值 value = self.fat_matrix[(n // self.fat_per_cluster) % self.fat_per_cluster, n % self.fat_per_cluster] return value ^ Fat.ALLOCATED_BIT if value \u0026 Fat.ALLOCATED_BIT \u003e 0 else value # 最高位为8代表正常使用的簇，其它值代表簇未分配，最高位为8时，取低31位的整形值 04 条目数据结构 条目是所有文件和目录的元数据，条目的数据结构如下：\nstruct Entry { uint16 mode; uint16 unknown; // ignore uint32 length; char created[8]; uint32 cluster; uint32 dir_entry; // ignore char modified[8]; uint32 attr; // ignore char padding[28]; // ignore char name[32]; char padding[416]; // ignore }; 使用struct.unpack()解包：\nstruct.Struct(\"","wordCount":"1491","inLanguage":"en","datePublished":"2023-09-29T17:49:16Z","dateModified":"2023-09-29T17:49:16Z","author":{"@type":"Person","name":"路边的阿不"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://babyno.top/posts/2023/09/exporting-file-from-ps2-memcard/"},"publisher":{"@type":"Organization","name":"路边的阿不","logo":{"@type":"ImageObject","url":"https://babyno.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://babyno.top/ accesskey=h title="路边的阿不 (Alt + H)">路边的阿不</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://babyno.top/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://babyno.top/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://babyno.top/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://babyno.top/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://babyno.top/>Home</a>&nbsp;»&nbsp;<a href=https://babyno.top/posts/>Posts</a></div><h1 class=post-title>从PS2记忆卡中导出存档文件</h1><div class=post-meta><span title='2023-09-29 17:49:16 +0000 UTC'>2023-09-29 17:49:16</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;路边的阿不</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#01-%e8%a7%a3%e6%9e%90superblock aria-label="01 解析SuperBlock">01 解析<code>SuperBlock</code></a></li><li><a href=#02-%e8%af%bb%e5%8f%96page%e5%92%8ccluster aria-label="02 读取page和cluster">02 读取<code>page</code>和<code>cluster</code></a></li><li><a href=#03-%e6%9e%84%e5%bb%bafat%e7%9f%a9%e9%98%b5 aria-label="03 构建FAT矩阵">03 构建<code>FAT</code>矩阵</a></li><li><a href=#04-%e6%9d%a1%e7%9b%ae%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="04 条目数据结构">04 条目数据结构</a></li><li><a href=#05-%e8%a7%a3%e6%9e%90%e6%9d%a1%e7%9b%ae%e7%b0%87%e5%92%8c%e6%95%b0%e6%8d%ae%e7%b0%87 aria-label="05 解析“条目簇”和“数据簇”">05 解析“条目簇”和“数据簇”</a></li><li><a href=#06-%e8%af%bb%e5%8f%96%e5%ad%98%e5%82%a8%e5%8d%a1%e4%b8%ad%e7%9a%84%e6%89%80%e6%9c%89%e6%96%87%e4%bb%b6 aria-label="06 读取存储卡中的所有文件">06 读取存储卡中的所有文件</a></li><li><a href=#07-%e5%af%bc%e5%87%ba%e6%b8%b8%e6%88%8f%e5%ad%98%e6%a1%a3 aria-label="07 导出游戏存档">07 导出游戏存档</a></li><li><a href=#08-%e7%bb%93%e5%b0%be aria-label="08 结尾">08 结尾</a></li><li><a href=#09-%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae aria-label="09 参考文献">09 参考文献</a></li></ul></div></details></div><div class=post-content><p>上一篇文章中我们解析了PS2存储卡的文件系统，这次直接实战，编写<code>python</code>代码导出指定的游戏存档。本篇文章完整代码可以访问：https://github.com/caol64/ps2mc-browser。</p><h2 id=01-解析superblock>01 解析<code>SuperBlock</code><a hidden class=anchor aria-hidden=true href=#01-解析superblock>#</a></h2><p><code>SuperBlock</code>结构如下，大小为340字节：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SuperBlock</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> magic[<span style=color:#ae81ff>28</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> version[<span style=color:#ae81ff>12</span>];
</span></span><span style=display:flex><span>    uint16 page_size;
</span></span><span style=display:flex><span>    uint16 pages_per_cluster;
</span></span><span style=display:flex><span>    uint16 pages_per_block;
</span></span><span style=display:flex><span>    uint16 unknown; <span style=color:#75715e>// ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    uint32 clusters_per_card;
</span></span><span style=display:flex><span>    uint32 alloc_offset;
</span></span><span style=display:flex><span>    uint32 alloc_end;
</span></span><span style=display:flex><span>    uint32 rootdir_cluster;
</span></span><span style=display:flex><span>    uint32 backup_block1; <span style=color:#75715e>// ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    uint32 backup_block2; <span style=color:#75715e>// ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    uint32 unknown[<span style=color:#ae81ff>2</span>]; <span style=color:#75715e>// ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    uint32 ifc_list[<span style=color:#ae81ff>32</span>];
</span></span><span style=display:flex><span>    uint32 bad_block_list[<span style=color:#ae81ff>32</span>]; <span style=color:#75715e>// ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    byte card_type;
</span></span><span style=display:flex><span>    byte card_flags;
</span></span><span style=display:flex><span>    byte unknown; <span style=color:#75715e>// ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    byte unknown; <span style=color:#75715e>// ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>使用<code>struct.unpack()</code>解包：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>struct<span style=color:#f92672>.</span>Struct(<span style=color:#e6db74>&#34;&lt;28s12sHHH2xLLLL4x4x8x128s128xbbxx&#34;</span>)<span style=color:#f92672>.</span>unpack(byte_val)
</span></span></code></pre></div><p>得到<code>page_size</code>和<code>pages_per_cluster</code>。</p><h2 id=02-读取page和cluster>02 读取<code>page</code>和<code>cluster</code><a hidden class=anchor aria-hidden=true href=#02-读取page和cluster>#</a></h2><p>根据公式计算<code>page</code>和<code>cluster</code>大小：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>self<span style=color:#f92672>.</span>spare_size <span style=color:#f92672>=</span> (self<span style=color:#f92672>.</span>page_size <span style=color:#f92672>//</span> <span style=color:#ae81ff>128</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>4</span> <span style=color:#75715e># 备用区域字节数</span>
</span></span><span style=display:flex><span>self<span style=color:#f92672>.</span>raw_page_size <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>page_size <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>spare_size <span style=color:#75715e># 算上备用区域的page字节数</span>
</span></span><span style=display:flex><span>self<span style=color:#f92672>.</span>cluster_size <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>page_size <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>pages_per_cluster <span style=color:#75715e># 簇字节数</span>
</span></span></code></pre></div><p>读取<code>page</code>和<code>cluster</code>，<code>spare area</code>里的内容是被舍弃掉的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_page</span>(self, n): <span style=color:#75715e># n为page编号</span>
</span></span><span style=display:flex><span>    offset <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>raw_page_size <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>byte_val[offset: offset <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>page_size]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_cluster</span>(self, n): <span style=color:#75715e># n为cluster编号</span>
</span></span><span style=display:flex><span>    page_index <span style=color:#f92672>=</span> n <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>pages_per_cluster
</span></span><span style=display:flex><span>    byte_buffer <span style=color:#f92672>=</span> bytearray()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(self<span style=color:#f92672>.</span>pages_per_cluster):
</span></span><span style=display:flex><span>        byte_buffer <span style=color:#f92672>+=</span> self<span style=color:#f92672>.</span>read_page(page_index <span style=color:#f92672>+</span> i)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bytes(byte_buffer)
</span></span></code></pre></div><h2 id=03-构建fat矩阵>03 构建<code>FAT</code>矩阵<a hidden class=anchor aria-hidden=true href=#03-构建fat矩阵>#</a></h2><p>从上一篇文章知道<code>FAT</code>矩阵的构建方式如下：
<img loading=lazy src=/static/imgs/posts/2023-09-29-exporting-file-from-ps2-memcard/%E5%AD%98%E5%82%A8%E5%8D%A1-FAT2.jpg alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__build_fat_matrix</span>(self):
</span></span><span style=display:flex><span>    indirect_fat_matrix <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__build_matrix(self<span style=color:#f92672>.</span>ifc_list) <span style=color:#75715e># 从ifc_list构建间接FAT</span>
</span></span><span style=display:flex><span>    indirect_fat_matrix <span style=color:#f92672>=</span> indirect_fat_matrix<span style=color:#f92672>.</span>reshape(indirect_fat_matrix<span style=color:#f92672>.</span>size) <span style=color:#75715e># 间接FAT是个一维数组</span>
</span></span><span style=display:flex><span>    indirect_fat_matrix <span style=color:#f92672>=</span> [x <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> indirect_fat_matrix <span style=color:#66d9ef>if</span> x <span style=color:#f92672>!=</span> Fat<span style=color:#f92672>.</span>UNALLOCATED] <span style=color:#75715e># 排除掉0xFFFFFFFF这种未分配的</span>
</span></span><span style=display:flex><span>    fat_matrix <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__build_matrix(indirect_fat_matrix) <span style=color:#75715e># 从间接FAT构建直接FAT</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fat_matrix
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__build_matrix</span>(self, cluster_list):
</span></span><span style=display:flex><span>    matrix <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((len(cluster_list), self<span style=color:#f92672>.</span>fat_per_cluster), np<span style=color:#f92672>.</span>uint32) <span style=color:#75715e># 初始化矩阵</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> index, v <span style=color:#f92672>in</span> enumerate(cluster_list): <span style=color:#75715e># 遍历cluster</span>
</span></span><span style=display:flex><span>        cluster_value <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>read_cluster(v) <span style=color:#75715e># 读出每个cluster的256个FAT</span>
</span></span><span style=display:flex><span>        cluster_value_unpacked <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>frombuffer(cluster_value, np<span style=color:#f92672>.</span>uint32)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> index0, v0 <span style=color:#f92672>in</span> enumerate(cluster_value_unpacked):
</span></span><span style=display:flex><span>            matrix[index, index0] <span style=color:#f92672>=</span> v0 <span style=color:#75715e># 给矩阵赋值</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> matrix
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_fat_value</span>(self, n): <span style=color:#75715e># 给出簇编号n，找到其对应的FAT的值</span>
</span></span><span style=display:flex><span>    value <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>fat_matrix[(n <span style=color:#f92672>//</span> self<span style=color:#f92672>.</span>fat_per_cluster) <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>fat_per_cluster, n <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>fat_per_cluster]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> value <span style=color:#f92672>^</span> Fat<span style=color:#f92672>.</span>ALLOCATED_BIT <span style=color:#66d9ef>if</span> value <span style=color:#f92672>&amp;</span> Fat<span style=color:#f92672>.</span>ALLOCATED_BIT <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> value <span style=color:#75715e># 最高位为8代表正常使用的簇，其它值代表簇未分配，最高位为8时，取低31位的整形值</span>
</span></span></code></pre></div><h2 id=04-条目数据结构>04 条目数据结构<a hidden class=anchor aria-hidden=true href=#04-条目数据结构>#</a></h2><p>条目是所有文件和目录的元数据，条目的数据结构如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Entry</span> {
</span></span><span style=display:flex><span>    uint16 mode;
</span></span><span style=display:flex><span>    uint16 unknown; <span style=color:#75715e>// ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    uint32 length;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> created[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>    uint32 cluster;
</span></span><span style=display:flex><span>    uint32 dir_entry; <span style=color:#75715e>// ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span> modified[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>    uint32 attr; <span style=color:#75715e>// ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span> padding[<span style=color:#ae81ff>28</span>]; <span style=color:#75715e>// ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>32</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> padding[<span style=color:#ae81ff>416</span>]; <span style=color:#75715e>// ignore
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>使用<code>struct.unpack()</code>解包：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>struct<span style=color:#f92672>.</span>Struct(<span style=color:#e6db74>&#34;&lt;H2xL8sL4x8s4x28x32s416x&#34;</span>)<span style=color:#f92672>.</span>unpack(byte_val)
</span></span></code></pre></div><p>每个条目的大小为512字节，条目里最重要的字段是<code>cluster</code>，标识了该条目对应的文件或目录的簇编号。如果本条目是目录，则对应的簇编号是“条目簇”；如果本条目是文件，则对应的簇编号是“文件簇”。另一个重要字段是<code>length</code>，如果本条目是目录，则对应的是目录下的条目数；如果本条目是文件，则对应的是文件的字节数。</p><h2 id=05-解析条目簇和数据簇>05 解析“条目簇”和“数据簇”<a hidden class=anchor aria-hidden=true href=#05-解析条目簇和数据簇>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_entry_cluster</span>(self, cluster_offset): <span style=color:#75715e># 读取条目，条目是512字节，一个簇可以包含多个条目</span>
</span></span><span style=display:flex><span>    cluster_value <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>read_cluster(cluster_offset <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>alloc_offset)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Entry<span style=color:#f92672>.</span>build(cluster_value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_data_cluster</span>(self, entry): <span style=color:#75715e># 读取数据，要从第一个簇开始读取到文件结束</span>
</span></span><span style=display:flex><span>    byte_buffer <span style=color:#f92672>=</span> bytearray()
</span></span><span style=display:flex><span>    chain_start <span style=color:#f92672>=</span> entry<span style=color:#f92672>.</span>cluster
</span></span><span style=display:flex><span>    bytes_read <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> chain_start <span style=color:#f92672>!=</span> Fat<span style=color:#f92672>.</span>CHAIN_END:
</span></span><span style=display:flex><span>        to_read <span style=color:#f92672>=</span> min(entry<span style=color:#f92672>.</span>length <span style=color:#f92672>-</span> bytes_read, self<span style=color:#f92672>.</span>cluster_size)
</span></span><span style=display:flex><span>        byte_buffer <span style=color:#f92672>+=</span> self<span style=color:#f92672>.</span>read_cluster(chain_start <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>alloc_offset)[:to_read]
</span></span><span style=display:flex><span>        bytes_read <span style=color:#f92672>+=</span> to_read
</span></span><span style=display:flex><span>        chain_start <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>get_fat_value(chain_start)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bytes(byte_buffer)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>build</span>(byte_val):
</span></span><span style=display:flex><span>    entry_count <span style=color:#f92672>=</span> len(byte_val) <span style=color:#f92672>//</span> Entry<span style=color:#f92672>.</span>__size
</span></span><span style=display:flex><span>    entries <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(entry_count):
</span></span><span style=display:flex><span>        entries<span style=color:#f92672>.</span>append(Entry(byte_val[i <span style=color:#f92672>*</span> Entry<span style=color:#f92672>.</span>__size: i <span style=color:#f92672>*</span> Entry<span style=color:#f92672>.</span>__size <span style=color:#f92672>+</span> Entry<span style=color:#f92672>.</span>__size]))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> entries
</span></span></code></pre></div><h2 id=06-读取存储卡中的所有文件>06 读取存储卡中的所有文件<a hidden class=anchor aria-hidden=true href=#06-读取存储卡中的所有文件>#</a></h2><p>上一篇文章说过，根目录没有条目，它的首个“条目簇”在超级块的<code>rootdir_cluster</code>中，它的“包含条目数”在<code>.</code>这个条目中。</p><p>要读取存储卡中的所有文件，第一步是解析根目录下所有条目，再解析条目下所有文件。因此只要循环调用以下方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_sub_entries</span>(self, parent_entry):
</span></span><span style=display:flex><span>    chain_start <span style=color:#f92672>=</span> parent_entry<span style=color:#f92672>.</span>cluster
</span></span><span style=display:flex><span>    sub_entries <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> chain_start <span style=color:#f92672>!=</span> Fat<span style=color:#f92672>.</span>CHAIN_END:
</span></span><span style=display:flex><span>        entries <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>read_entry_cluster(chain_start)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> e <span style=color:#f92672>in</span> entries:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> len(sub_entries) <span style=color:#f92672>&lt;</span> parent_entry<span style=color:#f92672>.</span>length:
</span></span><span style=display:flex><span>                sub_entries<span style=color:#f92672>.</span>append(e<span style=color:#f92672>.</span>unpack())
</span></span><span style=display:flex><span>        chain_start <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>get_fat_value(chain_start)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [x <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> sub_entries <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> x<span style=color:#f92672>.</span>name<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;.&#39;</span>)]
</span></span></code></pre></div><p>结果如下：</p><pre tabindex=0><code>BISCPS-15119sv01
    GameData
    BISCPS-15119sv01
    icon00.ico
    icon.sys
BISCPS-15116sv01
    GameData
    BISCPS-15116sv01
    icon00.ico
    icon.sys
BASLUS-21441DBZT2
    icon.sys
    dbzsn.ico
    BASLUS-21441DBZT2
...
</code></pre><h2 id=07-导出游戏存档>07 导出游戏存档<a hidden class=anchor aria-hidden=true href=#07-导出游戏存档>#</a></h2><p>既然所有文件条目都已经读取出来了，我们只要写个方法，根据输入的游戏名称，即可导出目录下的所有文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>export</span>(self, name, dest):
</span></span><span style=display:flex><span>    dir_path <span style=color:#f92672>=</span> dest <span style=color:#f92672>+</span> os<span style=color:#f92672>.</span>sep <span style=color:#f92672>+</span> name
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(dir_path):
</span></span><span style=display:flex><span>        os<span style=color:#f92672>.</span>mkdir(dir_path)
</span></span><span style=display:flex><span>    entries <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>lookup_entry_by_name(name)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> e <span style=color:#f92672>in</span> entries:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> e<span style=color:#f92672>.</span>is_file():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>with</span> open(dir_path <span style=color:#f92672>+</span> os<span style=color:#f92672>.</span>sep <span style=color:#f92672>+</span> e<span style=color:#f92672>.</span>name, <span style=color:#e6db74>&#39;wb&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>                f<span style=color:#f92672>.</span>write(self<span style=color:#f92672>.</span>ps2mc<span style=color:#f92672>.</span>read_data_cluster(e))
</span></span></code></pre></div><h2 id=08-结尾>08 结尾<a hidden class=anchor aria-hidden=true href=#08-结尾>#</a></h2><p>至此，我们已经可以把一个游戏的存档从存储卡中导出来了。如果你有<code>python</code>运行环境，可以直接运行文章一开始提供的<code>github</code>链接里的代码。</p><p>下一篇我们将分析一下每个存档文件里的<code>icon.sys</code>和<code>xxx.ico</code>文件，这两个文件是存档3d特效的数据文件。</p><h2 id=09-参考文献>09 参考文献<a hidden class=anchor aria-hidden=true href=#09-参考文献>#</a></h2><ul><li><a href=https://www.ps2savetools.com/ps2memcardformat.html>Ross Ridge - PlayStation 2 Memory Card File System</a></li><li><a href=https://git.sr.ht/~thestr4ng3r/mymcplus>Florian Märkl - mymcplus</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://babyno.top/tags/playstation2/>Playstation2</a></li><li><a href=https://babyno.top/tags/python/>Python</a></li></ul><nav class=paginav><a class=prev href=https://babyno.top/posts/2023/10/parsing-ps2-3d-icon/><span class=title>« Prev</span><br><span>解析PS2游戏存档3D图标</span></a>
<a class=next href=https://babyno.top/posts/2023/09/parsing-ps2-memcard-file-system/><span class=title>Next »</span><br><span>解析PS2记忆卡文件系统</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://babyno.top/>路边的阿不</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>