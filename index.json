[{"content":"简介 在上一篇文章里我们介绍了PS2使用的图片压缩算法RLE，这次我们再来研究一下它的纹理贴图编码算法——A1B5G5R5。\n对于纹理来说，常用的图片编码格式如jpg或png都不适合。因为图片是由GPU读取并进行渲染的，你总不能送过去一张jpg图片，让GPU要读取其中一个像素的时候，先把整个图片解码吧？因此最理想的图片格式是未经压缩的位图格式，可以根据像素点坐标直接获取RGB数据。今天要介绍的A1B5G5R5正是这种编码格式之一。\n分析 上面两张纹理图片是从PS2存档中提取出来的，它们以位图的形式储存，像素数量为128x128。\n标准的32位位图，每个像素占用4字节数据，分别储存了RGBA四个通道的数据。因此上面两个纹理图片的图片大小为128x128x4字节。32位RGBA每像素数据结构如下：\n对于A1B5G5R5编码来说，每个像素占用2字节数据，其中alpha通道占用1位，其它3种颜色各占5位。每像素数据结构如下：\n将A1B5G5R5解码为32位RGBA可以用下图的方法进行。\n伪代码如下：\n1 2 3 4 5 6 7 while tex_offset \u0026lt; len(self.texture): b = tex_struct.unpack_from(self.texture, tex_offset)[0] out[rgb_tex_offset] = (b \u0026amp; 0x1F) \u0026lt;\u0026lt; 3 # R out[rgb_tex_offset + 1] = ((b \u0026gt;\u0026gt; 5) \u0026amp; 0x1F) \u0026lt;\u0026lt; 3 # G out[rgb_tex_offset + 2] = ((b \u0026gt;\u0026gt; 10) \u0026amp; 0x1F) \u0026lt;\u0026lt; 3 # B rgb_tex_offset += 3 tex_offset += tex_struct.size 很明显可以看到，将32位的RGBA图片编码成16位的A1B5G5R5，会丢失每种色彩的最后3个bit数据，是一种有损编码格式，但带来的好处是压缩比2:1，图片缩小了一半。再配合上一篇讲到的RLE编码，可以进一步缩小图片大小。\n最后 最后放上上面两个纹理图片渲染后的效果，有小伙伴还记得这两个游戏吗？\n","permalink":"https://babyno.top/posts/2023/10/ps2-texture-encoding-algorithm-a1b5g5r5/","summary":"简介 在上一篇文章里我们介绍了PS2使用的图片压缩算法RLE，这次我们再来研究一下它的纹理贴图编码算法——A1B5G5R5。 对于纹理来说，常用","title":"PS2纹理图片编码算法A1B5G5R5"},{"content":" RLE算法介绍 RLE（Run Length Encoding，行程长度编码）算法，是把文件内容用“重复次数x数据”的形式来表示的压缩方法。比如：有AAAAAABBCDDEEEEEF这样一段数据，在字符后面加上重复出现次数，就可以用6A2B1C2D5E1F来表示。可以看到原始数据是17字节，编码后是12字节，因此压缩是成功的。\n让我们再看一串数据：ABCDE，如果按照上面的算法，编码后为1A1B1C1D1E，原始数据是5字节，编码后是10字节，毫无疑问这种压缩方式是失败的。\n为什么第二种字符串压缩会失败呢？细心的朋友一定看出来是因为它的字符重复出现的次数很少，因此使用“重复次数x数据”反而增加了数据长度。那有没有办法解决这个“缺陷”呢？答案是有的。我们接下来介绍在PS2游戏机中，是如何使用RLE算法来压缩图片的。\nRLE算法在PS2中的应用 在PS2中，图片文件的前4个字节指示了压缩后文件的大小。接下来的数据按照rle_code + 数据块的格式重复排列。需要注意的是，在PS2这里，rle_code和数据块中的每个数据，都是2字节，这点是与其它传统的RLE算法普遍为1字节最大的不同。\nrle_code的最高位是标识位，如果这一位是1，则表示后面紧跟着的数据块是“非重复数据”，类似于上面的ABCDE。此时将0x8000减去rle_code的后7位，得到的是数据块的长度。此时只需取出后面紧跟的该长度的数据块即可。\n如果标识位为0，则表示后面紧跟着的数据块是“重复数据”，类似于AAAAA，此时rle_code就是重复次数，只要取出后面紧跟着的一个数据块，重复rle_code次即可。\n伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 while rle_offset \u0026lt; compressed_size: rle_code = rle_code_struct.unpack_from(self.byte_val, rle_offset)[0] rle_offset += 2 if rle_code \u0026amp; 0x8000: next_bytes = 0x8000 - (rle_code ^ 0x8000) texture_buf += self.byte_val[rle_offset: rle_offset + next_bytes * 2] rle_offset += next_bytes * 2 else: times = rle_code if times \u0026gt; 0: next_byte = self.byte_val[rle_offset: rle_offset + 2] for _ in range(times): texture_buf += next_byte rle_offset += 2 总结 如果在一个文件中，能连续遇到大量重复的数据，RLE算法可以提供很好的压缩效果。但对于出现连续的“非重复数据”，需要使用改良过的算法进行优化。PS2使用的是众多改良算法的一种，比较简单，也很方便初学者对该算法的学习。\n","permalink":"https://babyno.top/posts/2023/10/rle-algorithm-in-ps2/","summary":"RLE算法介绍 RLE（Run Length Encoding，行程长度编码）算法，是把文件内容用“重复次数x数据”的形式来表示的压缩方法。比如：有AAAA","title":"RLE算法在PS2中的应用"},{"content":" 经过前面一系列文章的铺垫，PS2存档3D图标的文件已经全部解析完毕。本篇开始将介绍使用如下工具将3D图标渲染出来，并尽可能接近PS2主机原生的效果。\nPython3 PyGame Numpy ModernGL PyGLM 01 初始化PyGame和ModernGL 第一步先初始化PyGame，设置窗口大小为640x480，FPS为60。开启OpenGL渲染模式，OpenGL的版本号设置为3.3。\n1 2 3 4 5 6 7 8 9 import pygame as pg pg.init() pg.display.gl_set_attribute(pg.GL_CONTEXT_MAJOR_VERSION, 3) pg.display.gl_set_attribute(pg.GL_CONTEXT_MINOR_VERSION, 3) pg.display.gl_set_attribute(pg.GL_CONTEXT_PROFILE_MASK, pg.GL_CONTEXT_PROFILE_CORE) pg.display.set_mode((640, 480), flags=pg.OPENGL | pg.DOUBLEBUF) self.clock = pg.time.Clock() self.clock.tick(60) 接着初始化ModernGL，非常简单，只要创建一个context，开启深度测试和面剔除。\n1 2 3 4 import moderngl as mgl self.ctx = mgl.create_context() self.ctx.enable(flags=mgl.DEPTH_TEST | mgl.CULL_FACE) 02 获取顶点、纹理、法线等数据 这部分内容在上一篇解析PS2游戏存档3D图标有详细描述，就不展开了，这里只贴一下icon.sys的数据结构供参考。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct IconSys { char magic[4]; uint16 unknown; // ignore uint16 subtitle_line_break; uint16 unknown; // ignore uint32 bg_transparency; uint32 bg_color_upper_left[4]; uint32 bg_color_upper_right[4]; uint32 bg_color_lower_left[4]; uint32 bg_color_lower_right[4]; float32 light_pos1[4]; float32 light_pos2[4]; float32 light_pos3[4]; float32 light_color1[4]; float32 light_color2[4]; float32 light_color3[4]; float32 ambient[4]; char subtitle[68]; char icon_file_normal[64]; char icon_file_copy[64]; char icon_file_delete[64]; char zeros[512]; // ignore }; 03 坐标系统 这里以右手系统创建坐标系，但是原始的顶点是y轴颠倒的，如下图A。因此我们之后的工作将在转换后的图B坐标系下进行。 04 变换矩阵 观察矩阵 上图B中，摄像机位置在z轴的负延伸方向，我们稍稍向y轴负方向移动一小段距离，这样可以使视线不是对着图标的脚部，而是稍稍靠上一点，因此将摄像机位置坐标设为(0, -2, -10)。因为要将y轴颠倒，可以直接将摄像机向上的方向设置为y轴的负方向。这样一来lookAt矩阵创建如下：\n1 2 3 self.position = glm.vec3(0, -2, -10) self.up = glm.vec3(0, -1, 0) self.view = glm.lookAt(self.position, glm.vec3(0, -2, 0), self.up) 投影矩阵 投影矩阵可以用如下公式获得\n1 self.proj = glm.perspective(glm.radians(50), window_width / window_height, 0.1, 100) 模型矩阵 创建模型矩阵的目的是控制模型对象在3D空间中的位置变化，在这里模型对象需要在空间里绕着y轴做360度的旋转。\n1 2 3 4 5 6 # 初始化模型矩阵 self.m_model = glm.mat4() # 使模型绕y轴旋转，转过的角度为经过的时间。 # 初始化的180度是为了让模型在开始的时候背对着画面，更接近PS2主机的行为 m_model = glm.rotate(self.m_model, glm.radians(180) + animation_time / 2, glm.vec3(0, 1, 0)) 05 创建着色器 这里一共需要创建四个着色器\n背景顶点着色器 背景片段着色器 Icon顶点着色器 Icon片段着色器 背景着色器 背景着色器比较简单，只要创建一个覆盖整个坐标系的矩形，并且设置在离摄像机最远的那个坐标平面上即可。参考上面的图B，这个平面应该是z轴的0.9999。这个矩形的四个顶点的坐标分别为(-1, 1), (-1, -1), (1, -1), (1, 1)，对应的颜色在icon.sys中可以解析出来。根据这四个顶点和颜色，就可以构建背景VBO及VAO，这里不做过多描述。\n1 2 3 4 5 6 7 8 9 10 11 12 // bg.vert #version 330 core in vec2 vertexPos; in vec4 vertexColor; out vec3 fragColor0; void main() { fragColor0 = vertexColor.rgb; gl_Position = vec4(vertexPos.xy, 0.9999, 1.0); } 1 2 3 4 5 6 7 8 9 10 11 12 // bg.frag #version 330 core in vec3 fragColor0; out vec4 fragColor; uniform float alpha0; void main() { fragColor = vec4(fragColor0, alpha0); } Icon着色器 Icon着色器会比较复杂，我们先尝试着把Icon顶点渲染出来。还记得每个图标有多个形状吗？形状与动画相关，我们现在只取其中的一个形状组成VBO和VAO。\n1 2 3 4 5 6 7 8 9 10 11 12 // icon.vert #version 330 core in vec4 vertexPos; uniform mat4 proj; uniform mat4 view; uniform mat4 model; void main() { gl_Position = proj * view * model * vec4(vertexPos.xyz, 1); } 1 2 3 4 5 6 7 8 // icon.frag #version 330 core out vec4 fragColor; void main() { fragColor = vec4(0, 0, 0, 1); } 以下是运行代码后的效果：\n添加纹理 在上面的基础上，引入纹理坐标和纹理数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // icon.vert #version 330 core in vec4 vertexPos; in vec2 texCoord; in vec4 vertexColor; out vec4 fragColor0; out vec2 uv0; uniform mat4 proj; uniform mat4 view; uniform mat4 model; void main() { uv0 = texCoord; fragColor0 = vertexColor; gl_Position = proj * view * model * vec4(vertexPos.xyz, 1); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // icon.frag #version 330 core in vec2 uv0; in vec4 fragColor0; out vec4 fragColor; uniform sampler2D texture0; void main() { float alpha = fragColor0.a; vec3 color = fragColor0.rgb * texture(texture0, uv0).rgb; fragColor = vec4(color, alpha); } 添加光照 在上面的基础上，引入光源，环境光以及法线数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // icon.vert #version 330 core in vec4 vertexPos; in vec2 texCoord; in vec4 vertexColor; in vec4 normal; out vec4 fragColor0; out vec2 uv0; out vec3 normal0; out vec3 fragPos0; uniform mat4 proj; uniform mat4 view; uniform mat4 model; void main() { uv0 = texCoord; fragColor0 = vertexColor; normal0 = mat3(model) * normalize(normal.xyz); gl_Position = proj * view * model * vec4(vertexPos.xyz, 1); fragPos0 = gl_Position.xyz; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // icon.frag #version 330 core #define MAX_NUM_TOTAL_LIGHTS 3 in vec2 uv0; in vec4 fragColor0; in vec3 normal0; in vec3 fragPos0; out vec4 fragColor; struct Light { vec4 pos; vec4 color; }; uniform sampler2D texture0; uniform vec4 ambient; uniform Light lights[MAX_NUM_TOTAL_LIGHTS]; void main() { vec3 normal = normalize(normal0); float alpha = fragColor0.a; vec3 color = fragColor0.rgb * texture(texture0, uv0).rgb; vec3 diffuse = vec3(0.0, 0.0, 0.0); for (int i = 0; i \u0026lt; MAX_NUM_TOTAL_LIGHTS; i++) { vec3 lightDir = normalize(lights[i].pos.xyz - fragPos0); float diff = max(dot(lightDir, normal), 0.0); diffuse += diff * lights[i].color.rgb; } color = (ambient.rgb + diffuse) * color; fragColor = vec4(color, alpha); } 动画效果 动画效果是让着色器按照时间渲染不同形状的顶点数据。我们可以设计一个计时器和一个计数器，以确定当前时间应该渲染哪个形状的顶点。\nframe_length 完成动画效果需要的实际帧数，实际帧率等于60FPS animation_time 动画运行时间 anim_speed 动画播放速度 frame_length / animation_shapes 一个形状包含多少帧 1 2 3 4 animation_time = time.time() - self.start_time curr_frame = int(animation_time * self.window.fps * self.icon.anim_speed) % self.icon.frame_length curr_shape = int(curr_frame // (self.icon.frame_length / self.icon.animation_shapes)) 使动画平滑过渡 使动画平滑过渡需要使用着色器的顶点插值技术。我们在发送着色器顶点的时候，将当前形状和下一个形状的顶点数据同时发送。这样再根据时间因子，着色器会自动计算两个形状之间的顶点。\ntween_factor 计算当前时间戳在整个形状中所占帧的百分比 1 2 curr_frame_in_shape = curr_frame % frames_in_shape / frames_in_shape tween_factor = glm.float32(curr_frame_in_shape) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // icon.vert #version 330 core in vec4 vertexPos; in vec2 texCoord; in vec4 vertexColor; in vec4 nextVertexPos; in vec4 normal; out vec4 fragColor0; out vec2 uv0; out vec3 normal0; out vec3 fragPos0; uniform mat4 proj; uniform mat4 view; uniform mat4 model; uniform float tweenFactor; void main() { uv0 = texCoord; fragColor0 = vertexColor; normal0 = mat3(model) * normalize(normal.xyz); vec4 basePos = vec4(mix(vertexPos.xyz, nextVertexPos.xyz, tweenFactor), 1.0); gl_Position = proj * view * model * basePos; fragPos0 = gl_Position.xyz; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // icon.frag #version 330 core #define MAX_NUM_TOTAL_LIGHTS 3 in vec2 uv0; in vec4 fragColor0; in vec3 normal0; in vec3 fragPos0; out vec4 fragColor; struct Light { vec4 pos; vec4 color; }; uniform sampler2D texture0; uniform vec4 ambient; uniform Light lights[MAX_NUM_TOTAL_LIGHTS]; void main() { vec3 normal = normalize(normal0); float alpha = fragColor0.a; vec3 color = fragColor0.rgb * texture(texture0, uv0).rgb; vec3 diffuse = vec3(0.0, 0.0, 0.0); for (int i = 0; i \u0026lt; MAX_NUM_TOTAL_LIGHTS; i++) { vec3 lightDir = normalize(lights[i].pos.xyz - fragPos0); float diff = max(dot(lightDir, normal), 0.0); diffuse += diff * lights[i].color.rgb; } color = (ambient.rgb + diffuse) * color; fragColor = vec4(color, alpha); } 最终效果：\n06 尾声 所有代码均可在 https://github.com/caol64/ps2mc-browser 下载到。在我的第一篇文章中，我也提到了这个系列的创作初衷：为了纪念逝去的青春，以及对技术永不磨灭的热情。在此收尾，也算还了年少时的一个梦想。\n07 参考文献 gothi - icon.sys format Martin Akesson - PS2 Icon Format v0.5 Florian Märkl - mymcplus Ross Ridge - PlayStation 2 Memory Card File System ","permalink":"https://babyno.top/posts/2023/10/rendering-ps2-3d-icon/","summary":"经过前面一系列文章的铺垫，PS2存档3D图标的文件已经全部解析完毕。本篇开始将介绍使用如下工具将3D图标渲染出来，并尽可能接近PS2主机原生","title":"使用Python和OpenGL渲染PS2存档3D图标"},{"content":" 看到这个图片，对于熟悉PS2的老玩家来说应该不会陌生。它是PS2记忆卡管理界面中的游戏存档3D图标。本篇文章我们将介绍如何从存档文件里解析出这个活动的小人。\n01 解析目标 A：我们能从存档文件中解析到什么？\n图标模型的所有顶点、法线 图标模型的动作帧 光照 纹理及纹理坐标 背景颜色及透明度 B：我们需要做什么？\n编写着色器渲染背景和图标 将图标模型的动作帧组成动画 构建模型矩阵、视图矩阵、透视矩阵，使显示接近PS2原生效果 完成整个功能估计需要两篇文章，本篇主要介绍A。\n02 解析icon.sys 上一篇我们介绍了如何导出游戏的存档文件，事实上每个存档里都会有一个icon.sys的文件，这个可以看作图标的配置文件。icon.sys是一个固定大小（964字节）的文件，其结构如下：\noffset length description 0 byte[4] magic：PS2D 4 uint16 0 6 uint16 游戏标题换行符所在位置，注1 8 uint32 0 12 uint32 bg_transparency，背景透明度，0-255 16 uint32[4] bg_color，背景左上角颜色（RGB-，0-255） 32 uint32[4] bg_color，背景右上角颜色（RGB-，0-255） 48 uint32[4] bg_color，背景左下角颜色（RGB-，0-255） 64 uint32[4] bg_color，背景右下角颜色（RGB-，0-255） 80 uint32[4] light_pos1，光源1（XYZ-，0-1） 96 uint32[4] light_pos2，光源2（XYZ-，0-1） 112 uint32[4] light_pos3，光源3（XYZ-，0-1） 128 uint32[4] light_color1，光源1颜色（RGB-，0-1） 144 uint32[4] light_color2，光源2颜色（RGB-，0-1） 160 uint32[4] light_color3，光源3颜色（RGB-，0-1） 176 uint32[4] ambient，环境光（RGB-，0-1） 192 byte[68] sub_title，游戏标题（空字符结尾, S-JIS编码） 260 byte[64] icon_file_normal，普通图标文件名（空字符结尾），注2 324 byte[64] icon_file_copy，拷贝图标文件名（空字符结尾），注2 388 byte[64] icon_file_delete，删除图标文件名（空字符结尾），注2 452 byte[512] 全0 注1：游戏标题sub_title显示为2行，该值即为在标题的第几个字节换行，如图：\n注2：每个游戏存档可以对应3个图标icon文件，分别在不同场景显示。\n可以看到icon.sys文件里主要提供了背景、光照等数据，另外一个比较重要的部分是3d图标所在的文件名。\n03 解析icon文件 不像icon.sys文件，每个游戏的icon文件是不确定的，大小不确定，数量也不确定，但至少会有1个。有的游戏拷贝图标和删除图标与普通图标共用一个图标。\n3.1 文件结构 名称 说明 Icon头 固定大小，20个字节 顶点段 保存图标模型的所有顶点和法线数据 动画段 保存图标模型动画帧信息 纹理段 保存图标模型纹理 3.2 Icon头 Icon头存储了我们解码不同数据段所需的所有重要信息，其中包括：\n“顶点段”中包含的顶点数量以及动画形状的数量 纹理数据是否经过压缩 在图标文件中，Icon头总是位于偏移量 0 处。以下是Icon头结构：\nOffset Length Description 0000 uint32 magic：0x010000 0004 uint32 animation_shapes，动画形状，注1 0008 uint32 tex_type，纹理类型，注2 0012 uint32 未知，固定值0x3F800000 0016 uint32 vertex_count，顶点数量，必定是3的倍数 注1：图标模型有几套不同的顶点数据，对应不同的动作，称之为“形状”。将不同的形状循环渲染，即可形成动画效果。\n注2：“纹理类型”这部分尚不明确，该值是4字节整形，我总结出来每个位相应的功能如下表，未必正确：\nmask Description 0001 未知 0010 未知 0100 图标文件中存在纹理数据，有些游戏（如ICO）没有纹理数据，图标全黑 1000 图标文件中的纹理数据是被压缩过的 3.3 顶点段 PS2 图标中的多边形总是由三个顶点形成的三角形组成。由于顶点是按一定规律排列的，因此只需按照规律读取顶点数据，就能轻松构建多边形。利用OpenGL或类似工具渲染这些数据，就能得到一个漂亮的图标线框。\n“顶点段”包含图标中所有顶点的数据。每个顶点数据包含一组顶点坐标、法线坐标、纹理坐标以及一组RGBA数据，因此，拥有m个顶点和 n个形状的“顶点段”数据结构如下：\n顶点坐标 每个顶点坐标占用8字节，结构如下：\nOffset Length Description 0000 int16 X坐标，使用时需除以4096 0002 int16 Y坐标，使用时需除以4096 0004 int16 Z坐标，使用时需除以4096 0006 uint16 未知 法线坐标 每个法线坐标与顶点坐标数据结构一致。\n纹理坐标 每个纹理坐标占用4字节，结构如下：\nOffset Length Description 0000 int16 U坐标，使用时需除以4096 0002 int16 V坐标，使用时需除以4096 顶点RGBA 每个顶点颜色占用4字节，结构如下：\nOffset Length Description 0000 uint8 R，0-255 0001 uint8 G，0-255 0002 uint8 B，0-255 0003 uint8 A，0-255 3.4 动画段 很遗憾关于“动画段”里的大部分内容，我还没完全搞懂含义。不过不用太在意，利用“顶点坐标插值”，仍然可以完成动画动作。\n以下是“动画段”的数据结构：\n“动画段”包含“动画头”和若干“动画帧”，每个“动画帧”包含若干“关键帧”。\n动画头 “动画头”结构如下：\nOffset Length Description 0000 uint32 magic：0x01 0004 uint32 frame length：“动画帧”完成一个循环所需的“播放帧”，根据这个值可以计算出每个“动画帧”对应的“播放帧”数量 0008 float32 anim speed：播放速度，作用未知 0012 uint32 play offset：起始播放帧，作用未知 0016 uint32 frame count：“动画段”一共有几个“动画帧”，一般一个“形状”对应一个“动画帧” 帧数据Frame Data “帧数据”直接位于“动画头”之后。\nOffset Type Description 0000 u32 Shape id 0004 u32 Number of keys 0008 u32 UNKNOWN 0012 u32 UNKNOWN 关键帧Frame Key Offset Type Description 0000 f32 Time 0004 f32 Value 3.5 纹理段 纹理是像素为128x128的图片，使用TIM图像格式进行编码。根据Icon头里的tex_type字段，纹理分为未压缩和压缩两种类型。\n未压缩纹理 未压缩纹理的像素格式为BGR555，其中B、G、R各占用5bit，总共15bit，占用2字节（1个bit冗余）。如图：\n1 2 3 4 High-order byte: Low-order byte: X B B B B B G G G G G R R R R R X = Don\u0026#39;t care, R = Red, G = Green, B = Blue 因此原始图片大小固定为128x128x2字节。如果需将它的像素格式转为RGB24，可以用如下方法：\n1 2 High-order byte: Middle-order byte: Low-order byte: R R R R R 0 0 0 G G G G G 0 0 0 B B B B B 0 0 0 将5bit的色彩值转为8bit时，需将低3位补0。经过上述转换，每像素字节数变为3字节。同理也可将格式转为RGBA32，每像素字节数变为4字节。\n压缩纹理 压缩纹理使用非常简单的RLE算法进行压缩。第一个u32是压缩纹理数据的大小。其后的数据始终为u16的rle_code和rle_data交替出现，直到结束。 rle_data有两个变量：data数量x和重复次数y。rle_code作为计数器存在，如果小于0xFF00，则x = 1，y = rle_code；如果大于等于0xFF00，则x = (0x10000 - rle_code)，y = 1。如下图。\n将压缩纹理解压后，再根据上一节的内容即可转换为RGB24或RGBA32的图片。\n04 结尾 至此为止图标的相关文件已经解析完毕了，万事俱备只欠东风，下一篇我们即将开始渲染模式，使用PyGame和ModernGL将渲染动画显示出来。\n05 参考资料 gothi - icon.sys format Martin Akesson - PS2 Icon Format v0.5 ","permalink":"https://babyno.top/posts/2023/10/parsing-ps2-3d-icon/","summary":"看到这个图片，对于熟悉PS2的老玩家来说应该不会陌生。它是PS2记忆卡管理界面中的游戏存档3D图标。本篇文章我们将介绍如何从存档文件里解析出","title":"解析PS2游戏存档3D图标"},{"content":"上一篇文章中我们解析了PS2存储卡的文件系统，这次直接实战，编写python代码导出指定的游戏存档。本篇文章完整代码可以访问：ps2mc-browser。\n01 解析SuperBlock SuperBlock结构如下，大小为340字节：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct SuperBlock { char magic[28]; char version[12]; uint16 page_size; uint16 pages_per_cluster; uint16 pages_per_block; uint16 unknown; // ignore uint32 clusters_per_card; uint32 alloc_offset; uint32 alloc_end; uint32 rootdir_cluster; uint32 backup_block1; // ignore uint32 backup_block2; // ignore uint32 unknown[2]; // ignore uint32 ifc_list[32]; uint32 bad_block_list[32]; // ignore byte card_type; byte card_flags; byte unknown; // ignore byte unknown; // ignore }; 使用struct.unpack()解包：\n1 struct.Struct(\u0026#34;\u0026lt;28s12sHHH2xLLLL4x4x8x128s128xbbxx\u0026#34;).unpack(byte_val) 得到page_size和pages_per_cluster。\n02 读取page和cluster 根据公式计算page和cluster大小：\n1 2 3 self.spare_size = (self.page_size // 128) * 4 # 备用区域字节数 self.raw_page_size = self.page_size + self.spare_size # 算上备用区域的page字节数 self.cluster_size = self.page_size * self.pages_per_cluster # 簇字节数 读取page和cluster，spare area里的内容是被舍弃掉的：\n1 2 3 4 5 6 7 8 9 10 def read_page(self, n): # n为page编号 offset = self.raw_page_size * n return self.byte_val[offset: offset + self.page_size] def read_cluster(self, n): # n为cluster编号 page_index = n * self.pages_per_cluster byte_buffer = bytearray() for i in range(self.pages_per_cluster): byte_buffer += self.read_page(page_index + i) return bytes(byte_buffer) 03 构建FAT矩阵 从上一篇文章知道FAT矩阵的构建方式如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __build_fat_matrix(self): # 从ifc_list构建间接FAT indirect_fat_matrix = self.__build_matrix(self.ifc_list) # 间接FAT是个一维数组 indirect_fat_matrix = indirect_fat_matrix.reshape(indirect_fat_matrix.size) # 排除掉0xFFFFFFFF这种未分配的 indirect_fat_matrix = [x for x in indirect_fat_matrix if x != Fat.UNALLOCATED] # 从间接FAT构建直接FAT fat_matrix = self.__build_matrix(indirect_fat_matrix) return fat_matrix def __build_matrix(self, cluster_list): # 初始化矩阵 matrix = np.zeros((len(cluster_list), self.fat_per_cluster), np.uint32) # 遍历cluster for index, v in enumerate(cluster_list): # 读出每个cluster的256个FAT cluster_value = self.read_cluster(v) cluster_value_unpacked = np.frombuffer(cluster_value, np.uint32) for index0, v0 in enumerate(cluster_value_unpacked): # 给矩阵赋值 matrix[index, index0] = v0 return matrix # 给出簇编号n，找到其对应的FAT的值 def get_fat_value(self, n): value = self.fat_matrix[(n // self.fat_per_cluster) % self.fat_per_cluster, n % self.fat_per_cluster] # 最高位为8代表正常使用的簇，其它值代表簇未分配，最高位为8时，取低31位的整形值 return value ^ Fat.ALLOCATED_BIT if value \u0026amp; Fat.ALLOCATED_BIT \u0026gt; 0 else value 04 条目数据结构 条目是所有文件和目录的元数据，条目的数据结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct Entry { uint16 mode; uint16 unknown; // ignore uint32 length; char created[8]; uint32 cluster; uint32 dir_entry; // ignore char modified[8]; uint32 attr; // ignore char padding[28]; // ignore char name[32]; char padding[416]; // ignore }; 使用struct.unpack()解包：\n1 struct.Struct(\u0026#34;\u0026lt;H2xL8sL4x8s4x28x32s416x\u0026#34;).unpack(byte_val) 每个条目的大小为512字节，条目里最重要的字段是cluster，标识了该条目对应的文件或目录的簇编号。如果本条目是目录，则对应的簇编号是“条目簇”；如果本条目是文件，则对应的簇编号是“文件簇”。另一个重要字段是length，如果本条目是目录，则对应的是目录下的条目数；如果本条目是文件，则对应的是文件的字节数。\n05 解析“条目簇”和“数据簇” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 读取条目，条目是512字节，一个簇可以包含多个条目 def read_entry_cluster(self, cluster_offset): cluster_value = self.read_cluster(cluster_offset + self.alloc_offset) return Entry.build(cluster_value) # 读取数据，要从第一个簇开始读取到文件结束 def read_data_cluster(self, entry): byte_buffer = bytearray() chain_start = entry.cluster bytes_read = 0 while chain_start != Fat.CHAIN_END: to_read = min(entry.length - bytes_read, self.cluster_size) byte_buffer += self.read_cluster(chain_start + self.alloc_offset)[:to_read] bytes_read += to_read chain_start = self.get_fat_value(chain_start) return bytes(byte_buffer) def build(byte_val): entry_count = len(byte_val) // Entry.__size entries = [] for i in range(entry_count): entries.append(Entry(byte_val[i * Entry.__size: i * Entry.__size + Entry.__size])) return entries 06 读取存储卡中的所有文件 上一篇文章说过，根目录没有条目，它的首个“条目簇”在超级块的rootdir_cluster中，它的“包含条目数”在.这个条目中。\n要读取存储卡中的所有文件，第一步是解析根目录下所有条目，再解析条目下所有文件。因此只要循环调用以下方法：\n1 2 3 4 5 6 7 8 9 10 def find_sub_entries(self, parent_entry): chain_start = parent_entry.cluster sub_entries = [] while chain_start != Fat.CHAIN_END: entries = self.read_entry_cluster(chain_start) for e in entries: if len(sub_entries) \u0026lt; parent_entry.length: sub_entries.append(e.unpack()) chain_start = self.get_fat_value(chain_start) return [x for x in sub_entries if not x.name.startswith(\u0026#39;.\u0026#39;)] 结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 BISCPS-15119sv01 GameData BISCPS-15119sv01 icon00.ico icon.sys BISCPS-15116sv01 GameData BISCPS-15116sv01 icon00.ico icon.sys BASLUS-21441DBZT2 icon.sys dbzsn.ico BASLUS-21441DBZT2 ... 07 导出游戏存档 既然所有文件条目都已经读取出来了，我们只要写个方法，根据输入的游戏名称，即可导出目录下的所有文件。\n1 2 3 4 5 6 7 8 9 def export(self, name, dest): dir_path = dest + os.sep + name if not os.path.exists(dir_path): os.mkdir(dir_path) entries = self.lookup_entry_by_name(name) for e in entries: if e.is_file(): with open(dir_path + os.sep + e.name, \u0026#39;wb\u0026#39;) as f: f.write(self.ps2mc.read_data_cluster(e)) 08 结尾 至此，我们已经可以把一个游戏的存档从存储卡中导出来了。如果你有python运行环境，可以直接运行文章一开始提供的github链接里的代码。\n下一篇我们将分析一下每个存档文件里的icon.sys和xxx.ico文件，这两个文件是存档3d特效的数据文件。\n09 参考文献 Ross Ridge - PlayStation 2 Memory Card File System Florian Märkl - mymcplus ","permalink":"https://babyno.top/posts/2023/09/exporting-file-from-ps2-memcard/","summary":"上一篇文章中我们解析了PS2存储卡的文件系统，这次直接实战，编写python代码导出指定的游戏存档。本篇文章完整代码可以访问：ps2mc-b","title":"从PS2记忆卡中导出存档文件"},{"content":" 01 前言 作为一个80后的游戏老玩家，PS2游戏机在我心中一直有着特殊的地位。时至今日，已经过去了20多年，然而，最近我因为模拟器的缘故重新接触到了它。在重温了一段时间游戏后，我突发奇想，能否通过现在的知识来回忆年少时的自己？于是，我开始了这一系列文章的创作，从分析PS2存储卡的文件系统开始，逐步深入的解析其文件存储机制及每个游戏的存档文件。我的目标是，最终通过Python和OpenGL，模拟出游戏存档中经典的3D人物旋转效果，以此来纪念这个曾经陪伴我度过青春时光的经典游戏机。\n这是系列的第一篇作品，解析PS2存储卡的文件系统。\n02 词汇表 存储卡 指PS2实体机使用的专用记忆卡介质，使用时插在主机上，与主机是相互独立的两个设备。 NAND闪存 PS2存储卡使用的内部芯片，一种非易失性存储设备。 存储卡文件 指PS2模拟器使用的存储卡镜像文件，保存在模拟器所在的电脑磁盘上，以.ps2为后缀。是我们这篇文章解析的目标。 SuperBlock 超级块，位于文件系统开头的固定部分，由存储卡格式化时写入，不可更改，记录了存储卡的基本硬件指标。 page 页，文件系统的最小读写单元，页的大小定义于超级块中。 cluster 簇，文件系统中的最小分配单位，要保存一个文件至少需要一个簇。簇的大小定义于超级块中。 block 块，文件系统的最小擦除单位，块的大小定义于超级块中。 擦除 闪存初始化时页中的每一个bit都为1，写操作可以将bit置为0，但无法恢复为1。擦除是将bit恢复成1的唯一途径，但缺点是擦除以块为单位，哪怕只是修改一位数据，也得先擦除一个块，然后再用写操作把块的每一页恢复。这也是PS2游戏存档时普遍较慢的原因。 FAT 文件分配表，与FAT16和FAT32文件系统中的文件分配表类似。由于文件会保存在多个簇上，而簇可以是不连续的，为了确保在存取文件时能够检索到所有连续或不连续的簇地址，文件分配表采用了“簇链”这种链表的记录方式。 ifc indirect FAT cluster间接FAT簇，是一个簇，其中保存有存储卡上FAT簇的列表。 ifc_list ifc的数组，定义于超级块中。通过它可以找到ifc簇。 ECC 纠错码（Error Correction Code），闪存特性，写入page时需要对每一页进行纠错码计算，并写入spare area中。 spare area 备用区域，为每一个页保存ECC的一段空间。 entry 条目，存储卡上保存的文件或目录的基本信息单元，比如：文件（目录）名、大小、第一个簇编号等。 03 文件系统结构 注：这里用标准的8M存储卡举例。\n3.1 数据结构 从超级块中可得知页的大小是512字节，簇的大小是2个页。spare area可以根据公式(page_len / 128) * 4得到，是16字节，则文件系统基本数据结构如图：\n3.2 逻辑结构 了解了最基本的数据结构，接下来我们划分一下存储卡的逻辑结构。如下图，一块存储卡大致能分为以下几个逻辑区块。（黑白部分本文不涉及，可以忽略。）注意：组成逻辑区块的最小单位是簇。\n超级块 位于整个文件开头（也就是第一个簇）的前340个字节，这是文件系统中唯一具有固定位置的部分。下图示意了一个存储卡文件的超级块。\n注：PS2存储卡的字节序是小端序Little-endian。\nOffset Name Length Default Description 0 magic byte[28] - 固定字符串\u0026quot;Sony PS2 Memory Card Format\u0026quot;， 表明该卡已成功初始化 28 version byte[12] 1.X.0.0 版本号 40 page_len uint16 512 page的大小(以字节为单位) 42 pages_per_cluster uint16 2 簇中的页数 44 pages_per_block uint16 16 块中的页数 46 - uint16 0xFF00 未知 48 clusters_per_card uint32 8192 卡的总大小(以簇为单位) 52 alloc_offset uint32 41 第一个可分配簇 56 alloc_end uint32 8135 最后一个可分配簇 60 rootdir_cluster uint32 0 根目录的第一个簇，相对于alloc_offset 64 backup_block1 uint32 1023 本文无用 68 backup_block2 uint32 1022 本文无用 80 ifc_list uint32[32] 8 间接 FAT 簇列表，在标准 8M 卡上只有一个间接 FAT 簇 208 bad_block_list uint32[32] -1 本文无用 336 card_type byte 2 必须是2，说明这是一张PS2存储卡 337 card_flags byte 0x52 存储卡的物理特性 字段page_len、pages_per_cluster、pages_per_block和cluster_per_card定义文件系统的基本几何结构。可以使用ifc_list访问FAT，rootdir_cluster给出根目录的第一个簇。FAT和目录项中的簇偏移量都与alloc_offset相关。\nFAT 文件分配表是一个链表，当你找到一个文件的起始簇时，你想象有两个线程，线程x用来读取这个簇里的内容（即数据），线程y去FAT里寻找下一个簇，交由x读取，然后不断循环，当然两个线程不是必须的。这里引用一张图说明一下这种工作方式：\n已知文件A，起始簇是8 线程x去簇8读取第一块数据A0 线程y去FAT查找8的下一个簇是13 线程x继续读取簇13的数据A1 线程y去FAT查找13的下一个簇是7 不断循环 图片来源：https://www.slideserve.com/yahto/file-system-implementation\n直接FAT 由前文可以得知，直接FAT和间接FAT都是保存在簇里的。簇里的数据必须有一个良好的结构，才能使我们简单的解析成FAT链表。FAT在簇里的结构可以想象成长这样：\n这是一个矩阵M，行定义为FAT所在的簇，列定义为每个FAT簇里的数据。每个FAT簇，保存的都是4字节32位的整形数组，数量为1024 / 4 = 256个，因此矩阵有256列。FAT一共有多少个簇呢？这点可以在间接FAT的簇中解析出来，我们之后再讲。在这里FAT一共占据了32个簇，因此矩阵有32行。\nM矩阵的大小为32 * 256 = 8192，意味着这个FAT可以管理8192个簇。假设现在要找簇n在矩阵中的位置row和column，可以根据简单的计算得出：\n1 2 row = (n // 256) % 256 column = n % 256 既然已经计算出了位置，那就可以取到对应的值了，没错，这个值?就是下一个簇。通过不断循环，直到取到的值为0xFFFFFFFF，表示簇链到结尾了，不需要再查找了。\n注：FAT表里储存的值为32位，最高位为8代表正常使用的簇，其它值代表簇未分配，最高位为8时，取低31位的整形值。值为0xFFFFFFFF代表已是簇链末尾。\n间接FAT 前文留了一个问题，为什么FAT占有了32个簇？\n在超级块中有一个字段ifc_list，是一个4字节32位的整形数组，再想象一下上面出现的矩阵。ifc_list是一个只有一行的矩阵，虽然它有32个元素，但只有第一个有值，其值8即间接FAT簇ifc。将簇8的内容按照上文的方法解析出来，再形成一个矩阵，行是ifc_list的个数，理论上是32，但由于只有1个元素，因此这个矩阵的行也为1。矩阵的列依然是256。解析其中的值，可以得到FAT所在的簇为9到40，即32个。\n可分配簇 是一个范围，从alloc_offset开始到alloc_end结束。除去超级块、FAT、保留簇等的位置，所有的游戏存档都位于可分配簇内。\n04 文件和目录 接着我们要研究下可分配簇里，每个簇都保存了些什么东西？简单来说，可分配簇里只有两种簇：“条目簇”和“数据簇”。保存条目的簇称为“条目簇”，保存数据的簇称为“数据簇”。\n4.1 条目 每个目录或文件都有一个“条目”，可以看作是元数据，保存有文件名、大小、创建和修改时间等属性。每个“条目”的长度为 512 字节，因此每个 1024 簇中只能容纳两个“条目”。“条目簇”不会保存文件数据，即使“条目簇”里只有一个“条目”。\n除了根目录没有root这个“条目”外，每个目录都有以自己的目录名命名的“条目”，每个文件也有以自己的文件名命名的“条目”，“条目”的结构如下表：\nOffset Name Length Description 0 mode uint16 标识该文件的属性 4 length uint32 如果是文件，以字节为单位；如果是目录，以项为单位。 8 created byte[8] 创建时间 16 cluster uint32 条目对应的第一个簇，是相对于alloc_offset的相对值。 20 dir_entry uint32 无用 24 modified byte[8] 修改时间 32 attr uint32 用户属性 36 name byte[32] 文件名，x00以后的需截断 mode字段请参考：https://www.ps2savetools.com/ps2memcardformat.html 。是一个4字节整形数，每个字节用对应的掩码比对，即可识别“条目”对应的文件类型。比如：0x8427代表一个目录，0x8497代表一个文件。 cluster字段代表了“条目”的第一个簇。如果本条目是目录，则这个簇指向的是当前目录的下一个“条目簇”；如果本条目是文件，则这个簇指向的是文件的第一个“数据簇”。 每个目录下的第一个“条目簇”一定是名为.和..的两个目录，这两个目录项代表当前目录和父目录，就像在Unix中一样。 目录下有几个“条目”以及文件有几个字节都是由length字段决定的，当你按照“簇链”读取文件的时候，需要自己记录最后一个簇的哪里是最后一个字节。 05 结尾 至此，相信大家对一个ps2存储文件有了大致认识了吧。有兴趣的可以自己写一个程序解析下了。稍后我也会创建一个项目，附上本篇文章涉及的源代码。\n下一篇文章我们将开始把游戏存档从存储卡里导出来，看看每个游戏存档都有哪些文件。\n06 参考文献 本文主要参考了如下文章，在此表示感谢🙏：\nRoss Ridge - PlayStation 2 Memory Card File System ","permalink":"https://babyno.top/posts/2023/09/parsing-ps2-memcard-file-system/","summary":"01 前言 作为一个80后的游戏老玩家，PS2游戏机在我心中一直有着特殊的地位。时至今日，已经过去了20多年，然而，最近我因为模拟器的缘故重新接触","title":"解析PS2记忆卡文件系统"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nThe following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Inline Code This is Inline Code\nOnly pre Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with backticks and language specified 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Sample article showcasing basic Markdown syntax and formatting for HTML elements.\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nmermaid test 1 2 3 4 5 sequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;Bob: Hi Bob Bob-\u0026gt;\u0026gt;Alice: Hi Alice The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://babyno.top/posts/2019/03/hello-world/","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","title":"Hello World"}]