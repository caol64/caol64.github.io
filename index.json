[{"content":"感触 历史的长河深延，其中存在着那些被歌颂为“唐宗宋祖、李白杜甫”的人，他们的名字在历史的巨幕上浩然猎猎，引得后人口诵留香。\n而我们，普通的你我他，可能无法成为历史笔下的英雄。我们的名字，我们的词句，我们的故事，在历史的洪流中可能几乎无影无踪，像海中漫天的砂尘。\n但是，人生的价值并不在于他人的赞美或记忆，而在于我们自身如何看待自己的生活之路。你是你生命故事的主角，你的生活故事，你的所有瞬间，都是值得被铭记，被储存，被尊重的。\n经历 有那么一段历史，我小心翼翼地记录下了，这是份喜悦。然而由于没有恰当的维护，这份历史便渐渐消散，这是份遗憾。而现如今，我竭尽所能重新装配这些记忆，也许并不完美，但这是幸运。\n这段经历，蕴含着我在2011-2012年间上线的个人博客（3shi天下），以及我在博客上与一群网友的交流故事。转眼间十多年过去，这个博客已经无踪可寻，那些曾经的互动网友已与我失去联络。\n但正如我之前所说，“你是你人生的主角，你的生活经历，你的点滴，都值得被记录，被记忆，被尊重。” 这是一段难以忘却的经历，我矢志要记录它，珍惜它，尊重它。\n借助互联网的力量，我用尽所有办法为此博客中的内容进行恢复。\n最终恢复了大部分内容，你知道，有很多图片真的无法找回了。而且由于博客的框架也发生了变化（从wordpress变成了简洁的html），页面排版也不再一致。此外，域名和评论我也没打算迁移到这里。最后博客就只能复原成这样了——3shi天下。\n怀念 有句话说得好，“互联网是有记忆的”，这句话对每个人来说都是如此。我在 archive.org 找到了博客当年的截图。\n在Gmail的存档中，还能找到一些和网友互动的邮件。\n结尾 这篇文章稍显伤感，因为正反映了我近期的心境。最近我一直在整理可以回顾过去的东西，包括照片集、笔记、文章等。因此我想说：人生的每个阶段都值得回溯，但人的记忆有限，尽可能将这些珍贵的回忆记录在某个可以看得见的地方。你会发现，每个回忆中，你都是主角。\n","permalink":"https://babyno.top/posts/2024/01/you-are-the-protagonist-of-your-own-life/","summary":"感触 历史的长河深延，其中存在着那些被歌颂为“唐宗宋祖、李白杜甫”的人，他们的名字在历史的巨幕上浩然猎猎，引得后人口诵留香。 而我们，普通的你我","title":"再平凡的你，也是自己人生的主角"},{"content":"事情的起因 那天，家里的长辈的Android手机坏了，正好我这里有台闲置的苹果手机。你可能想：哦，这挺简单的吧，启动新手机，下载转移到 iOS的APP，一键迁移就完事了。然而往往事情都不会这么顺利，尤其是我之前没有做过这方面的迁移，正所谓“第一步错，步步错”来形容一点不为过。\n用转移到 iOS来迁移数据必须在iPhone激活之前进行。 一旦激活，你就不能指望它了。我就是没经验，顺序搞错了，先激活，再迁移微信和相册ok，直到迁移通讯录，发现没有现成工具可用，这时想起来使用转移到 iOSAPP，但为时已晚。\n阿里云盘不能备份通讯录，蓝牙也不能互传。迁移通讯录，就像是那一个执拗的孩子，打死不肯低头。\n苹果的高傲 老人家的安卓手机早已苍老，只能导出通讯录文件到本地，保存为.vcf文件。那怎么将.vcf文件导入到iPhone的通讯录呢？我在网上搜索答案，得到的解决方法是：需要通过网页版icloud的“导入vcard联系人”功能。既然有方法，那就试试看。然而过程有点头疼：当我尝试导入时，提示“无法导入”。\n那一刹那，我心里那个呐喊啊，“苹果哥，你就饶了我这个卑微的Android战士吧，我只是想导入一个文件而已！”\nvcard版本转换 我继续在网上搜索，发现可能是我导出的vcard是v2版本，而icloud支持的是v3版本。继续搜索得知：通过将vcard导入qq邮箱，再从qq邮箱导出，以此来将v2版本升级到v3版本。然而在实际操作中，这个方法并不起作用。现在回想起来，可能这就是神的旨意，让我们能够更好的机会去体验编程师的高级乐趣吧。\n遇到问题，当你已经尽力去解决，却无法得到答案时，怎会逃得过我们程序员的眼？在GitHub上，我找到了一个vcard2to3的转换工具。三下五除二，\u0026ldquo;clone\u0026quot;源代码-\u0026ldquo;运行\u0026rdquo;-\u0026ldquo;转换\u0026rdquo;-再次\u0026quot;导入icloud\u0026rdquo;，瞧！成功了！\n感想 生活中，你可能会遇到各种各样的问题和挑战，当你遇到问题，别忘了我们生活在一个丰富多彩的世界。你可以上网搜索，你可以问问身边的人，当然，你也可以行动起来，自己去解决问题。\n毕竟，对于我们程序员来说，解决问题不过是我们日常工作的一部分，正如这次的通讯录搬家大戏，虽然过程曲折，但最终我们还是找到了解决问题的方法。于是，无论是在生活中还是在工作中，只要我们肯动脑筋，肯实践，那么总会有问题被我们解决的那一刻。\n最后忍不住开一句玩笑，世上无难事，只要有GitHub，哈哈！\n","permalink":"https://babyno.top/posts/2024/01/importing-android-contacts-into-an-activated-ios-device/","summary":"事情的起因 那天，家里的长辈的Android手机坏了，正好我这里有台闲置的苹果手机。你可能想：哦，这挺简单的吧，启动新手机，下载转移到 iOS的","title":"将Android通讯录导入已激活IOS设备"},{"content":" 背景 记得三个月前我在GitHub上开源了ps2mc-browser项目，一个可以查看和渲染ps2存档3D图标的神奇小工具。间或推送代码，增添功能，如今终于发布了它的第一个稳定版本。\n然后我将目光转向了JetBrains的“开放源码开发许可证”。\nJetBrains Licenses for Open Source Development JetBrains是一家专注于构建最智能，最有效的开发工具的公司。他们提供了一项“开放源码开发许可证”的计划，以支持那些为开放源码社区做出贡献的开发者。\n基于这样的原因，我向JetBrains提交了申请。没想到，申请流程比我想象的要简单许多。只需要提供项目的相关信息，比如项目的链接，开源证书类型，项目的活动状态等等，然后把表单提交，就等待JetBrains官方进行审批就可以了。\n申请条件 必须符合开源定义，项目源代码公开，并具有相关的开源许可证如 MIT`` 许可证、Apache 2.0`` 等。\n定期开发，即每个月都应提交新代码。JetBrains 将自动检查项目过去三个月的活动情况。不包括非代码贡献（例如 README.md、.txt）和由 Dependabot 提交的内容。\n项目必须符合作为软件一部分的条件，例如作为框架、库、插件或应用程序。不适用于代码示例、博客，以及 LeetCode 解决方案。\n必须适当地为项目进行文档化，例如提供详细的 README 文件、行为规范，贡献指南等。\n项目不能由商业公司或组织（NGO、教育、研究或政府）持续资助。允许补偿服务器/基础设施成本和接受一次性自愿捐赠。\n项目的开发者应在空闲时间自愿维护，不支持在工作时间参与项目工作或有偿自由工作的贡献者。\n只提供软件的免费版本，不提供与项目相关的任何商业服务，如付费支持、咨询、客户 bug 修正等。\n免费许可证只提供给核心项目提交者，他们应对项目有定期贡献，这些贡献在仓库中应当可见。\n申请流程详细的步骤可以参考这个链接。\nJetBrains All Products Pack 在等待了2天后，我收到了JetBrains的邮件，告知我申请已经通过，并且提供了所有JetBrains All Products Pack的许可。\nJetBrains的\u0026quot;All Products Pack\u0026quot;许可证几乎涵盖了我需要的所有功能。从Java的IntelliJ IDEA，Python的PyCharm，前端的WebStorm到数据分析的DataGrip，以及许多其他的产品。\n这对我来说意味着什么呢？这仅仅意味着我有了多一些的选择来执行我的工作，以便更好的提升我的工作效率和编程质量。\n略微直接一些，有了这个“全面许可”，我不必再为是否购买高级版而犹豫，也不必再为试用期的结束而烦恼。我可以为自己的工作，尤其是开源项目找到更多的专注。\n在JetBrains的产品中，每一个都是一个优秀、高效的开发工具，无数的专业开发者都从中受益。\n结语 感谢JetBrains对开源社区的大力支持。同样，我也希望我的经验可能会有助于其他开源项目的维护者或者开发者，不要害怕尝试，勇敢地去申请你们的开源许可证，因为也许下一个接收惊喜的就是你。\n","permalink":"https://babyno.top/posts/2023/12/apply-for-jetbrains-oss-development-license/","summary":"背景 记得三个月前我在GitHub上开源了ps2mc-browser项目，一个可以查看和渲染ps2存档3D图标的神奇小工具。间或推送代码，增添","title":"申请到了JetBrains开源免费许可证"},{"content":"如何将多边形的顶点和纹理渲染成缤纷多彩的画面呢？我们需要通过一个窗口，窥探其中的奥秘，它就是OpenGL着色器。今天我们就要聊聊ps2mc-browser的着色器。\n这里简单介绍一下，ps2mc-browser是一个ps2存档查看器，它有能力解析ps2存档中3D图标的顶点和纹理等数据，并通过OpenGL的能力将图标渲染出来。\n在接下来的内容中，我将逐个解析ps2mc-browser中的六个OpenGL着色器。让我们一起深入理解他们是如何工作的吧。\n背景着色器(bg.frag和bg.vert) 主要负责渲染背景色。通过之前的文章我们知道icon.sys文件里提供了背景的四个顶点的颜色以及透明度数据。\n这里我们再回顾一下我们创建的坐标系统：\n因为我们创建出来的空间是一个每条边长度都是2的正立方体，而坐标所在的原点坐标是立方体的中心。此外我们的摄像机是在z轴的负方向，想象一下立方体的哪一个面应该是背景面：\n因此我们可以构建出背景的四个顶点坐标是：\n1 bg_vertex = [(-1, 1, 0.99), (-1, -1, 0.99), (1, -1, 0.99), (1, 1, 0.99)] 顺带一提，在着色器里，渲染是按照三角形为单位的，因此这个正方形的面应该是拆分成两个三角形组成。现在将这4个坐标分别填入对应的颜色值，着色器将渲染这整个面的颜色。\n1 2 3 4 5 6 7 // bg.frag #version 330 core in vec4 fragColor0; out vec4 fragColor; void main() { fragColor = fragColor0; } 在背景的片元着色器(bg.frag)中，我们需要输入一个颜色(fragColor0)，然后将它的值赋给输出颜色(fragColor)。这个过程其实就是渲染背景颜色。\n1 2 3 4 5 6 7 8 9 // bg.vert #version 330 core in vec3 vertexPos; in vec4 vertexColor; out vec4 fragColor0; void main() { fragColor0 = vertexColor; gl_Position = vec4(vertexPos, 1.0); } 在背景的顶点着色器(bg.vert)中，我们首先定义了一个顶点的位置(vertexPos)和一个颜色值(vertexColor)作为输入。然后我们将颜色值传递给了片元着色器，并设定顶点的位置(gl_Position)。\n可以说背景着色器的主要职责就是把我们希望看到的颜色填充到屏幕上。\n到这里还没有完，我们之前提到背景除了颜色数据还有透明度数据，那怎么将透明度体现出来呢？我们在刚才的背景图层后面，再加一层我们称之为skybox的层，并未此层添加一些颜色，这样，如果背景层有透明度，那天空层的颜色就会透过背景层展现一部分出来，达到视觉上感知的效果。\n1 2 3 4 5 6 7 skybox_vertex = [(-1, 1, 0.999), (-1, -1, 0.999), (1, -1, 0.999), (1, 1, 0.999)] skybox_colors = [ (0.6, 0.6, 0.6, 1), (0.6, 0.6, 0.6, 1), (0.6, 0.6, 0.6, 1), (0.6, 0.6, 0.6, 1), ] 最后来一张背景图效果，可以看到中间的颜色过渡效果是着色器插值自动计算的。\n图标着色器(icon.frag和icon.vert) 这是最复杂的一部分，它负责将从ps2存档中解析出来的3D图标绘制出来。上面提到，着色器是将顶点围成的三角形逐个渲染的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // icon.frag #version 330 core ... // Uniform variables uniform sampler2D texture0; // Texture uniform vec4 ambient; // Ambient light uniform mat4 model; // Model matrix uniform Light lights[MAX_NUM_TOTAL_LIGHTS]; // Array of lights void main() { // Calculate normalized normal vector vec3 normal = normalize(normal0).xyz; // Get color from the texture vec3 color = texture(texture0, uv0).rgb; // Calculate diffuse lighting vec3 diffuse = vec3(0); for (int i = 0; i \u0026lt; MAX_NUM_TOTAL_LIGHTS; i++) { vec3 lightDir = normalize(lights[i].dir.xyz); diffuse += max(dot(normal, lightDir), 0.0) * lights[i].color.rgb; } // Final color calculation vec4 finalColor = vec4((ambient.rgb + diffuse) * color, 1.0); fragColor = finalColor; } 在图标的片元着色器(icon.frag)里，“uniform”关键字代介我们的一些常量，包含了纹理(texture0)，环境光(ambient)，以及光照(lights)等。\n接着我们计算了一个单位法向量(normal)，从纹理中取得颜色，并计算漫反射光(diffuse)。具体来讲，每个灯光都会对漫反射光有贡献，这取决于灯光的方向和法向量的夹角。我们将所有灯光的贡献相加，就得到了最终的漫反射光。\n最后，我们将环境光和漫反射光与纹理颜色相乘后得到最终的颜色(finalColor)，并将其传给片元着色器的输出颜色(fragColor)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // icon.vert #version 330 core ... // Output variables for fragment shader out vec2 uv0; // Texture coordinates for fragment shader out vec4 normal0; // Transformed normal for fragment shader // Uniform matrices uniform mat4 proj; // Projection matrix uniform mat4 view; // View matrix uniform mat4 model; // Model matrix uniform float tweenFactor; // Tweening factor for vertex animation void main() { // Pass texture coordinates to fragment shader uv0 = texCoord; // Transform and pass normal to fragment shader normal0 = model * vec4(normal, 1); // Interpolate between current and next vertex positions based on tween factor vec4 basePos = vec4(mix(vertexPos, nextVertexPos, tweenFactor), 1.0); // Combine transformations and set the final vertex position gl_Position = proj * view * model * basePos; } 在图标的顶点着色器(icon.vert)中，我们通过uniform关键字设定了一些矩阵(proj，view，model)和一个插值因子(tweenFactor)。\n这里重点讲一下插值因子(tweenFactor)，这个值是3D图标能进行动画动作效果的关键。由于每个存档除了保存有图标完整的顶点外，还额外保存了完成一组动作的不同的顶点坐标，我们称之为动作帧，动作帧循环播放的时候就形成了动画效果。因此我们需要将相邻的动作帧的顶点坐标进行插值计算，tweenFactor就是当前的时间在本帧与下一帧之间的时间因子。\n然后我们将纹理坐标(uv0)和和法向量(normal0)传递给片元着色器。我们按插值因子在当前顶点位置(vertexPos)和下一顶点位置(nextVertexPos)之间插值，之后再由模型矩阵(model)进行变换，得到实际的顶点位置，并最后再通过视图矩阵(view)和投影矩阵(proj)将其变换到齐次裁剪空间。\n到这里图标着色器的任务就完成了。\n按钮着色器(circle.frag和circle.vert) 负责渲染与鼠标交互的按钮，ps2mc-browser可以显示存档中角色的多种不同动作，通过鼠标点击相应的按钮切换不同的动作。\n1 2 3 4 5 6 // circle.frag #version 330 core out vec4 fragColor; void main() { fragColor = vec4(1.0, 1.0, 1.0, 0.6); } 在这个circle.frag里，我们直接将颜色(fragColor)设定为不完全透明的白色，并不接受任何输入。\n1 2 3 4 5 6 // circle.vert #version 330 core in vec2 vertexPos; void main() { gl_Position = vec4(vertexPos, 0, 1.0); } 在circle.vert中，我们只需要接收一个顶点位置(vertexPos)作为输入，然后赋给OpenGL的内建变量gl_Position。\n简单来说，按钮着色器的工作就是画出一个不完全透明的白色的几何图形作为按钮。它要渲染的按钮数量和按钮坐标，都是由程序计算好以后传递给着色器的。\n总结 至此，我们已经详细讲解了ps2mc-browser如何通过OpenGL着色器来渲染3D动态图标。python和OpenGL都是我第一次接触，把它们整合到一块做了这个项目一开始我是没有想到的。之后可能还会对这个项目添加一些新功能，那我们下回再见。\n","permalink":"https://babyno.top/posts/2023/12/ps2mc-browsers-shader-introduction/","summary":"如何将多边形的顶点和纹理渲染成缤纷多彩的画面呢？我们需要通过一个窗口，窥探其中的奥秘，它就是OpenGL着色器。今天我们就要聊聊ps2mc-","title":"ps2mc-browser的着色器代码分析"},{"content":"苹果快捷指令是一款强大的工具，可以帮助我们自动化日常任务。在创建快捷指令时，有时我们需要添加附件，例如文本、图片、音频等。但是，苹果快捷指令本身并不支持添加附件，因此我们需要使用一些技巧来实现。\nBase64编码 Base64是一种编码格式，可以将任意数据转换为可存储和传输的字符串。苹果快捷指令支持添加文本，因此我们可以将附件编码成Base64字符串，然后通过文本的形式添加到快捷指令中。\n示例 假设我们需要创建一个快捷指令，生成一个模版“numbers”文件。我们可以先将“numbers”文件编码成Base64字符串，然后通过文本的形式添加到快捷指令中。\n以下是具体步骤：\n创建“numbers”文件，选择“文件”\u0026gt;“保存”。 使用如下“快捷指令”将其生成Base64字符串并保存在剪贴板中。 打开“快捷指令”应用，创建一个新的快捷指令。 在“操作”列表中，找到“文本”\u0026gt;“输入文本”。 在“文本”字段中，粘贴Base64字符串。 点击“保存”。 现在，我们就可以使用这个快捷指令来生成“numbers”文件了。\n下图是“加油记录”里的一个例子，首次执行快捷指令时，会自动创建一个模版numbers文件，这个模版文件就使用base64编码隐藏在快捷指令中。\n注意事项 Base64编码后的字符串可能会很长，因此我们需要注意输入文本的字数限制。此外，Base64编码后的字符串可能包含非法字符，因此我们需要在使用前进行检查。\n总结 Base64编码是一种可以帮助我们在苹果快捷指令中添加附件的有效技巧。它操作简单，而且可以应用于各种场景。\n","permalink":"https://babyno.top/posts/2023/12/the-wonders-of-base64-encoding-in-apple-shortcuts/","summary":"苹果快捷指令是一款强大的工具，可以帮助我们自动化日常任务。在创建快捷指令时，有时我们需要添加附件，例如文本、图片、音频等。但是，苹果快捷指令","title":"Base64编码在「Apple快捷指令」中的妙用"},{"content":"今天开始我创建了一个「快捷指令」专题，专门分享自己常用的Apple Shortcuts。我是一个喜欢效率的人，所以能够自动化的工作我都尽量不进行繁琐的逐步操作。希望这些「快捷指令」也能为你们的生活带来便利。\n今天分享第一个快捷指令：“加油记录”。\n由来 如果你跟我一样不喜欢安装专门的油耗APP，但又想记一笔自己的加油记录或者油耗开支，同时又懒得每次都正儿八经打开excel这样的表格软件，那你可以试试这个快捷指令。操作非常简单，你只需选择油号（92或者95），输入加油金额，其它全部自动完成。\n功能 自动获取油价 根据用户所处位置和所选油号自动获取当日油价（数据由「东方财富网」提供） 自动计算加油量 自动存档数据 需要设备上已经安装numbers应用，首次运行会自动创建表格，每次操作会在表格最后添加一条记录 存档数据支持多设备同步 numbers表格默认存储在icloud目录下，方便iPhone、iPad、MAC多端浏览。如果未开通icloud，也可以自己修改存储路径 支持多平台 支持iPhone、iPad、MAC 操作 打开快捷指令 选择92#或者95#汽油 输入加油金额 下载地址 https://www.icloud.com/shortcuts/914e212e8aff4a92a2a6deb676a3932e\n最后 如果遇到问题请反馈至https://github.com/caol64/apple-shortcuts。另外快捷指令修改方便，你也可以按照自己的使用场景自行修改，也欢迎将修改后的版本分享给我。\n","permalink":"https://babyno.top/posts/2023/11/shortcuts-sharing-fueling-record/","summary":"今天开始我创建了一个「快捷指令」专题，专门分享自己常用的Apple Shortcuts。我是一个喜欢效率的人，所以能够自动化的工作我都尽量不进","title":"「Apple快捷指令」分享 - 加油记录"},{"content":"ps2mc-browser是一个PS2存档文件查看器，使用OpenGL画布显示存档里的3D动态图标。依赖如下：\nPython3 WxPython Numpy ModernGL PyGlm Github地址戳这里。\n新功能 一些PS2游戏存档内置了三套不同的图标动画，分别对应玩家进行“浏览”、“拷贝”和“删除”这三种不同的操作。\n新发布的功能使得ps2mc-browser界面不仅仅只是展示图标的动画，还可以与用户进行交互，响应用户的鼠标操作。这样一来，图标的动画可以根据用户的选择而变化。\n其它更新 每个存档动画的背景图案都保存在icon.sys文件里（具体请查阅解析PS2游戏存档3D图标），实际上它是有透明度的，在PS2实体机上比较容易看出来。\n因此，在OpenGL渲染背景时，在bg背景层的后面，加了一层skybox。这两层的z坐标分布为0.99和0.999，且skybox的RGBA为(0.6, 0.6, 0.6, 1)不透明。这样如果bg有透明效果，那就会显示出skybox的颜色。\n以Viewtiful Joe为例，它的bg透明度是100%，如果不加skybox，其效果如下： 加上后效果如下： 未解决问题 光源问题尚未解决，导致很多游戏光照不正确显示效果不佳。详情见解析PS2游戏存档3D图标。\n","permalink":"https://babyno.top/posts/2023/11/ps2mc-browser-new-feature-release/","summary":"ps2mc-browser是一个PS2存档文件查看器，使用OpenGL画布显示存档里的3D动态图标。依赖如下： Python3 WxPython Numpy ModernGL PyGlm Github地址戳这","title":"ps2mc-browser新功能发布"},{"content":"在之前的文章中，我提到我通常使用 VSCode 进行写作。这一次，我想分享一些提高平时写作效率的小技巧。同时，这也是我第一次尝试使用刚刚注册的 ChatGPT，看看它在辅助编码方面的能力如何。\n需求背景 在使用 Hugo 创建新文章时，通常需要通过命令来执行操作，比如：\n1 hugo new content posts/2023/2023-10-21-hello-world.md 这个命令中，content 后面的内容是新文章的相对路径。按照我的偏好，我希望文章按年份归档，并且在文章标题前添加日期以便于检索。\n然而，问题在于每次都要输入这一长串命令，感觉相当繁琐。我觉得这个命令里除了 \u0026quot;hello world\u0026quot; 以外的部分都是可以自动生成的。因此，我的需求就产生了：我希望在 VSCode 中只需输入文章标题，就能自动生成文章模板。\n另外，考虑到我写的是中文博客，我对需求提出了更进一步的要求：输入标题时可以是中文，并且自动翻译成英文。比如，“世界，你好”应该自动翻译成 hello world。\n解决方案 为了实现这一需求，我选择了VSCode Task，方案如下：\n创建Task 编写脚本，使得在VSCode弹出输入框，接收输入的标题。 创建python脚本 将输入的标题生成对应的 Hugo 命令，并执行。 中英文翻译： 利用Google翻译API，将输入的中文标题翻译成英文。 实际操作 创建VSCode Task 在VSCode菜单栏中选择：Terminal -\u0026gt; Configure Tasks -\u0026gt; create tasks.json file from template -\u0026gt; Others，会自动在工作目录的.vscode文件夹下生成tasks.json文件。\n将tasks.json改成如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;new post\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;scripts/new_post.py\u0026#34;, \u0026#34;${input:title}\u0026#34;], \u0026#34;problemMatcher\u0026#34;: [] } ], \u0026#34;inputs\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;title\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Enter your title.\u0026#34; } ] } 说明一下，这段代码创建了一个名叫new post的task，底层使用shell脚本调用了名叫scripts/new_post.py的python脚本，并将用户输入的title作为参数输入。\n创建python脚本 接下来我们要请出今天的嘉宾——ChatGPT，让它帮我生成python脚本。\n先整理一下我的需求：\n我希望生成一个python脚本，要求：\n接收一个文本类型的输入参数：title 调用google翻译API将title翻译成英文 翻译后的title如果有多个单词，单词间用\u0026quot;-\u0026ldquo;连接 调用shell脚本hugo new content posts/${yyyy}/${yyyy-MM-dd}-${title}.md 将上述提示发给ChatGPT，以下是它的回复：\n您可以使用以下的 Python 脚本来实现您的需求。请确保您已经安装了 googletrans 库。您可以使用以下命令来安装它：\n1 pip install googletrans==4.0.0-rc1 接下来，您可以创建一个 Python 脚本，比如 translate_and_create_post.py，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import sys from googletrans import Translator import subprocess from datetime import datetime def translate_title(title): translator = Translator() translated_title = translator.translate(title, dest=\u0026#39;en\u0026#39;).text return translated_title.replace(\u0026#39; \u0026#39;, \u0026#39;-\u0026#39;) def create_post(title): today = datetime.today() formatted_date = today.strftime(\u0026#39;%Y-%m-%d\u0026#39;) translated_title = translate_title(title) file_name = f\u0026#34;content/posts/{today.year}/{formatted_date}-{translated_title}.md\u0026#34; subprocess.run([\u0026#34;hugo\u0026#34;, \u0026#34;new\u0026#34;, file_name]) print(f\u0026#34;Post created successfully: {file_name}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) != 2: print(\u0026#34;Usage: python translate_and_create_post.py \u0026lt;title\u0026gt;\u0026#34;) else: title = sys.argv[1] create_post(title) 这个脚本使用了 googletrans 库来将输入的标题翻译成英文，并按照您的要求进行了处理。然后，它使用 subprocess 模块来调用 hugo new 命令创建新的文章。\n使用方法示例：\n1 python translate_and_create_post.py \u0026#34;您的标题\u0026#34; 请注意，为了使用 Google 翻译 API，您可能需要提供 API 密钥。确保您已经按照 Google API 文档中的指南获取并配置了 API 密钥。\n嗬，看上去不错，赶紧把这段代码保存成scripts/new_post.py试一下。\n真不错，一次性成功，我的心还有点小激动。但还有点小问题，生成的模版里的title也被翻译成英文了，我想保留的是我的输入。只要用sed命令查找并替换就行了。有了刚才的经历，这点小事交给ChatGPT我信心十足。\n输入：\n我希望生成一个python脚本，要求：\n接收一个文本类型的输入参数：title 给定一个文本文件a.txt 使用sed命令找到文件中title: 开头的行，将title: 之后的内容替换为${title} 输出：\n如果您想使用sed命令替换文件中的文本，您可以在Python脚本中调用subprocess模块来执行sed命令。以下是一个示例脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import sys import subprocess def replace_title_in_file(title): file_path = \u0026#39;a.txt\u0026#39; sed_command = f\u0026#34;sed -i \u0026#39;s/title: .*/title: {title}/g\u0026#39; {file_path}\u0026#34; try: subprocess.run(sed_command, shell=True, check=True) print(f\u0026#34;Title replaced successfully in {file_path}\u0026#34;) except subprocess.CalledProcessError as e: print(f\u0026#34;Error: {e}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) != 2: print(\u0026#34;Usage: python replace_title_with_sed.py \u0026lt;title\u0026gt;\u0026#34;) else: title = sys.argv[1] replace_title_in_file(title) 这个脚本使用subprocess模块调用了sed命令，替换了文件中以title: 开头的行的内容。使用方法示例：\n1 python replace_title_with_sed.py \u0026#34;新的标题\u0026#34; 请确保脚本和a.txt文件在同一目录下，且您具有足够的权限读写a.txt文件。这个脚本会在文件中找到以title: 开头的行，并将其替换为新的标题。\n把replace_title_in_file方法复制到scripts/new_post.py文件里，并在刚才到操作完成后调用它即可。\n调试 本以为这一步也会像第一步那样顺利，但没想到事实打脸。这段代码运行报错。无奈只能将sed命令拷贝到终端调试。\n继续追问：\n使用sed命令找到文件中title: 开头的行，将该行title: 之后的内容替换为${title}\n回答：\n如果您只想使用 sed 命令替换文件中以 title: 开头的行的内容，可以在终端中执行如下命令：\n1 sed -i \u0026#39;s/^title: .*/title: ${title}/g\u0026#39; a.txt 还是不行，有点汗流浃背了。此时我突然意识到了什么，于是再次追问：\nmac环境下，使用sed命令找到文件中title: 开头的行，将该行title: 之后的内容替换为${title}\n回答：\n在 macOS 上，sed 的用法稍有不同。您可以使用以下命令来实现在文件中找到以 title: 开头的行，并将其后的内容替换为 ${title}：\n1 sed -i \u0026#39;\u0026#39; \u0026#39;s/^title: .*/title: ${title}/g\u0026#39; a.txt 在 macOS 上，-i 选项后需要提供一个备份文件的扩展名，即使不需要备份也要提供一个空字符串 ''。这样，sed 命令会直接在原始文件上进行修改。\n原来如此，mac下需要多一个参数，是我的锅，不能怪ChatGPT。\n稍作调整后，我继续进行操作：\n效果不错，还是挺满意的。\n总结 通过这样的优化，我现在只需专注于输入文章标题，而不再需要关心繁杂的命令。这大大提高了我的写作效率，使得整个流程更加流畅。\n最让人惊喜的是ChatGPT，它带给我的体验是震撼的。我没有尝试它的高级功能，但已经被它的魅力折服。看来是时候去深入了解它了。\n","permalink":"https://babyno.top/posts/2023/11/create-hugo-post-with-vscode-task-and-chatgpt/","summary":"在之前的文章中，我提到我通常使用 VSCode 进行写作。这一次，我想分享一些提高平时写作效率的小技巧。同时，这也是我第一次尝试使用刚刚注册的 ChatGP","title":"用VSCode Task自动化创建博客"},{"content":"起因 大约在十几年前，我也自己搭建过一个博客，在godaddy买了虚拟主机和一个域名，搭建好LAMP环境，再装上wordpress就开始折腾了。什么百度统计、google广告、jiathis等等全都安排上。那个时候在网上结识了一帮志同道合的网友，一起聊建站心得，甚至网站的PR值升到2时还兴奋的奔走相告。\n后来由于种种原因博客就荒废了，再后来就没有了……\n直到今年国庆前后，我写了一个PS2相关的开源项目，想把整理的一些文档分享到网上，所以开始物色一个平台。我的要求很简单，只要能完美支持markdown就可以了。因为我写的文章都是md格式保存的。\n一开始知乎是我的首选，还在上面创建了专栏。我被知乎文本编辑器里提示的“markdown语法识别中”迷惑了，本以为它可以支持markdown。但现实很打脸，这完全是个骗局，知乎不支持markdown。语雀、飞书、钉钉个人版虽然看着都不错，但其在线模式和私有格式，让我无法接受它们。\n这促使我有了再次搭建个人博客的想法……\n选型 相比于10年前，现在搭建博客的门槛低了不少，甚至不用买任何虚拟主机或云服务，完全免费。这中间，完美契合我的需求的是各种各样的Pages——Github Pages、Cloudflare Pages和Gitee Pages。平台提供免费的静态网站服务和免费的SSL证书，甚至SSL证书都是平台自动申请和续期。跟十年前相比，简直不要太方便。\n我的使用场景是这样的：\n先建立一个git仓库，这样我就有一个可以永久保存文件的地方，并且多端同步。 使用markdown格式写文章或者文档，按照自己喜欢的目录结构存放，提交到git仓库。 使用静态网站生成程序把markdown文件转换成html和css等静态资源。 发布到Pages服务。 我选择的是Github Pages + Hugo来生成我的博客。没有什么特殊原因，如果下次要选择我可能会选择其它的。\n建站 使用Hugo生成网站 网上教程很多，这里不做赘述。Hugo不是唯一选项，选择你喜欢的静态网站生成程序即可。\nHugo生成的目录模版是这样的：\n1 2 3 4 5 6 7 8 9 10 11 my-site/ ├── archetypes/ │ └── default.md ├── assets/ ├── content/ ├── data/ ├── i18n/ ├── layouts/ ├── static/ ├── themes/ └── hugo.toml \u0026lt;-- site configuration 创建的文章都在content目录下，编译时只要运行命令即可生成静态网站的所有资源。\n使用Github Pages运行网站 首先你需要在github上创建一个Github Pages的仓库，具体操作不做赘述。将上一步生成的静态资源上传到这个仓库中，触发预先配置好的workflow即可自动部署网站。\n如果你选择Hugo，下面这个地方的设置要注意\nBuild and deployment设置中workflow选择Deploy static content to Pages，由Hugo本地编译静态资源，可以大大提升Github Pages的部署速度。\n下面说一下域名的两种玩法。\n第一种玩法是博客使用github分配的域名，比如xxx.github.io，好处是真的是纯免费了，连域名都不花钱了。坏处是github.io在国内访问速度非常不稳定。这种玩法适合新手或者对博客要求不高的朋友。\n第二种玩法是自己购买一个域名，将域名绑定在Github Pages上。这一步需要配置，参考官方文档。配置完后Github会自动帮你申请SSL证书，你的网站就可以使用https连接了。当然自有域名的好处还有很多，请看下一节。\n使用Cloudflare优化网络 github在国内访问速度非常不稳定，体验不佳。如果你有自己的域名，可以注册一个Cloudflare账号，稍微配置一下就可以优化访问速度。\n第一步，使用Cloudflare的DNS解析。如果你的域名不是在Cloudflare购买的，需要先将域名注册商那里的DNS解析服务器换成Cloudflare的，比如腾讯： 第二步，使用dig命令查看Github Pages分配给你的域名的真实ip地址： 第三步，在Cloudflare控制台创建你的域名指向上述ip地址的DNS解析A记录： 嫌第二步和第三步麻烦的话，可以直接使用一条CNAME记录指向你的github.io域名，效果是一样的。\n其它的一些配置可以自己摸索一下，比如全站SSL和JS、CSS自动压缩等。设置好后，你可以使用一些测速网站来测试一下你的网站的访问速度，不出意外的话，应该比之前流畅多了。\n我之前图片CDN服务使用的是jsdelivr，奈何服务不稳定，换了Cloudflare感觉还行，用起来还简单，何乐不为呢？\n添加百度统计和Google Analytics 可以统计网站等访问量，PV、UV等数据，十几年前我的网站添加过，现在不知道有没有更好的。如果想添加的话，注册一个账号并且把一段jacascript代码贴在你的网页中就行。\n向搜索引擎提交你的网站 新网站上线，如果想要各大搜索引擎快速收录的话，主动提交自己的网址也是一个不错的手段。下面是几大搜索引擎的收录提交网址：\nGoogle Bing 百度 如果没有域名备案，百度收录比较困难\n个性化 主题 主题我选择了简约风格的PaperMod，照着说明配置即可。\n代码高亮 如果你不喜欢papermod默认的代码高亮风格，你需要禁用highlight.js并启用Chroma。大家注意以下步骤以避免踩坑。\n在hugo.yml里添加 1 2 3 params: assets: disableHLJS: true 在cunstom.css里添加： 1 2 3 4 5 6 :root { --hljs-bg: unset !important; } .dark { --hljs-bg: unset !important; } 在hugo.yml里添加，并把style换成Chroma Style Gallery里你喜欢的样式 1 2 3 4 5 6 7 markup: highlight: codeFences: true guessSyntax: true lineNos: true # noClasses: false style: monokailight 你可以刷新下页面，看看效果，如果感觉不错，就不用再折腾了。如果你还有更高的追求，比如高亮模块可以根据黑暗模式自动切换，那就要使用自定义css。\n修改hugo.yml 1 2 3 4 5 6 markup: highlight: codeFences: true guessSyntax: true lineNos: true noClasses: false 生成css文件 1 hugo gen chromastyles --style=monokailight \u0026gt; syntax.css 好了，你有css了，尽情折腾吧，比如黑暗模式变换背景颜色：\n1 2 3 4 5 6 7 8 9 10 .highlight\u0026gt;.chroma { background: var(--bg-c)!important; } :root { --bg-c: #fafafa; } .dark { --bg-c: rgba(175, 184, 193, 0.2); } 评论模块 静态网站添加评论模块有很多种方案，我选择的是waline，安装方法大家可以看它的官方文档。我把它部署在Vercel上，连接的数据库是LeanCloud，都是免费的。\nwaline支持黑暗模式的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* # Waline 黑暗模式 */ body.dark { /* 下面是官网默认的黑暗模式配色 */ /* 常规颜色 */ --waline-white: #000; --waline-light-grey: #666; --waline-dark-grey: #999; /* 布局颜色 */ --waline-color: #888; --waline-bgcolor: #1e1e1e; --waline-bgcolor-light: #272727; --waline-border-color: #333; --waline-disable-bgcolor: #444; --waline-disable-color: #272727; /* 特殊颜色 */ --waline-bq-color: #272727; /* 其他颜色 */ --waline-info-bgcolor: #272727; --waline-info-color: #666; --waline-border: 1px solid #888; } 如果你不喜欢waline默认主题的绿油油的颜色，可以换成蓝色。\n1 2 3 4 5 6 7 8 body.dark { --waline-theme-color: #318dec !important; --waline-active-color: #318dec !important; } :root { --waline-theme-color: #60a7f1 !important; --waline-active-color: #60a7f1 !important; } 支持mermaid语法 如果你想你的markdown能直接画图表，可以安装mermaid，安装方法在官网。效果如下：\nsequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! 顺带一说，由于jsdelivr的不稳定，我选择了cloudflare的cdn：https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.6.1/mermaid.esm.min.mjs\n显示文章TOC TOC就是侧边栏等文章大纲，如果不喜欢主题自带的TOC样式，可以自己定义。网上教程很多，不再赘述。比如下图：\n最后 到此为止，基本能满足我的需求了。最后放一张平时写文章时的图： 我通常使用VSCode编写文章，实时预览Markdown格式非常方便。为了让图片在VSCode和网页上都能正常显示，我在项目的根目录下创建了一个名为imgs的软链接，指向static/imgs。这是因为Hugo在编译时会自动将static目录下的文件复制到网站的根目录下，所以使用绝对路径/imgs/可以在不同预览方式下找到文件。\n我还创建了一个名为public的软链接，指向我的Github Pages仓库。当我完成文章的编写并使用Hugo进行编译时，它会自动将输出文件复制到public目录，即我的Github Pages仓库。最后，我使用git命令将更改推送到远程仓库，从而完成了网站的发布。\n最后欢迎大家访问我新建的小站：路边的阿不。\n","permalink":"https://babyno.top/posts/2023/11/new-hugo-blog/","summary":"起因 大约在十几年前，我也自己搭建过一个博客，在godaddy买了虚拟主机和一个域名，搭建好LAMP环境，再装上wordpress就开始折腾了","title":"用Github和Cloudflare自建博客"},{"content":"简介 在上一篇文章里我们介绍了PS2使用的图片压缩算法RLE，这次我们再来研究一下它的纹理贴图编码算法——A1B5G5R5。\n对于纹理来说，常用的图片编码格式如jpg或png都不适合。因为图片是由GPU读取并进行渲染的，你总不能送过去一张jpg图片，让GPU要读取其中一个像素的时候，先把整个图片解码吧？因此最理想的图片格式是未经压缩的位图格式，可以根据像素点坐标直接获取RGB数据。今天要介绍的A1B5G5R5正是这种编码格式之一。\n分析 上面两张纹理图片是从PS2存档中提取出来的，它们以位图的形式储存，像素数量为128x128。\n标准的32位位图，每个像素占用4字节数据，分别储存了RGBA四个通道的数据。因此上面两个纹理图片的图片大小为128x128x4字节。32位RGBA每像素数据结构如下：\n对于A1B5G5R5编码来说，每个像素占用2字节数据，其中alpha通道占用1位，其它3种颜色各占5位。每像素数据结构如下：\n将A1B5G5R5解码为32位RGBA可以用下图的方法进行。\n伪代码如下：\n1 2 3 4 5 6 7 while tex_offset \u0026lt; len(self.texture): b = tex_struct.unpack_from(self.texture, tex_offset)[0] out[rgb_tex_offset] = (b \u0026amp; 0x1F) \u0026lt;\u0026lt; 3 # R out[rgb_tex_offset + 1] = ((b \u0026gt;\u0026gt; 5) \u0026amp; 0x1F) \u0026lt;\u0026lt; 3 # G out[rgb_tex_offset + 2] = ((b \u0026gt;\u0026gt; 10) \u0026amp; 0x1F) \u0026lt;\u0026lt; 3 # B rgb_tex_offset += 3 tex_offset += tex_struct.size 很明显可以看到，将32位的RGBA图片编码成16位的A1B5G5R5，会丢失每种色彩的最后3个bit数据，是一种有损编码格式，但带来的好处是压缩比2:1，图片缩小了一半。再配合上一篇讲到的RLE编码，可以进一步缩小图片大小。\n最后 最后放上上面两个纹理图片渲染后的效果，有小伙伴还记得这两个游戏吗？\n","permalink":"https://babyno.top/posts/2023/10/ps2-texture-encoding-algorithm-a1b5g5r5/","summary":"简介 在上一篇文章里我们介绍了PS2使用的图片压缩算法RLE，这次我们再来研究一下它的纹理贴图编码算法——A1B5G5R5。 对于纹理来说，常用","title":"PS2纹理图片编码算法A1B5G5R5"},{"content":" RLE算法介绍 RLE（Run Length Encoding，行程长度编码）算法，是把文件内容用“重复次数x数据”的形式来表示的压缩方法。比如：有AAAAAABBCDDEEEEEF这样一段数据，在字符后面加上重复出现次数，就可以用6A2B1C2D5E1F来表示。可以看到原始数据是17字节，编码后是12字节，因此压缩是成功的。\n让我们再看一串数据：ABCDE，如果按照上面的算法，编码后为1A1B1C1D1E，原始数据是5字节，编码后是10字节，毫无疑问这种压缩方式是失败的。\n为什么第二种字符串压缩会失败呢？细心的朋友一定看出来是因为它的字符重复出现的次数很少，因此使用“重复次数x数据”反而增加了数据长度。那有没有办法解决这个“缺陷”呢？答案是有的。我们接下来介绍在PS2游戏机中，是如何使用RLE算法来压缩图片的。\nRLE算法在PS2中的应用 在PS2中，图片文件的前4个字节指示了压缩后文件的大小。接下来的数据按照rle_code + 数据块的格式重复排列。需要注意的是，在PS2这里，rle_code和数据块中的每个数据，都是2字节，这点是与其它传统的RLE算法普遍为1字节最大的不同。\nrle_code的最高位是标识位，如果这一位是1，则表示后面紧跟着的数据块是“非重复数据”，类似于上面的ABCDE。此时将0x8000减去rle_code的后7位，得到的是数据块的长度。此时只需取出后面紧跟的该长度的数据块即可。\n如果标识位为0，则表示后面紧跟着的数据块是“重复数据”，类似于AAAAA，此时rle_code就是重复次数，只要取出后面紧跟着的一个数据块，重复rle_code次即可。\n伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 while rle_offset \u0026lt; compressed_size: rle_code = rle_code_struct.unpack_from(self.byte_val, rle_offset)[0] rle_offset += 2 if rle_code \u0026amp; 0x8000: next_bytes = 0x8000 - (rle_code ^ 0x8000) texture_buf += self.byte_val[rle_offset: rle_offset + next_bytes * 2] rle_offset += next_bytes * 2 else: times = rle_code if times \u0026gt; 0: next_byte = self.byte_val[rle_offset: rle_offset + 2] for _ in range(times): texture_buf += next_byte rle_offset += 2 总结 如果在一个文件中，能连续遇到大量重复的数据，RLE算法可以提供很好的压缩效果。但对于出现连续的“非重复数据”，需要使用改良过的算法进行优化。PS2使用的是众多改良算法的一种，比较简单，也很方便初学者对该算法的学习。\n","permalink":"https://babyno.top/posts/2023/10/rle-algorithm-in-ps2/","summary":"RLE算法介绍 RLE（Run Length Encoding，行程长度编码）算法，是把文件内容用“重复次数x数据”的形式来表示的压缩方法。比如：有AAAA","title":"RLE算法在PS2中的应用"},{"content":" 经过前面一系列文章的铺垫，PS2存档3D图标的文件已经全部解析完毕。本篇开始将介绍使用如下工具将3D图标渲染出来，并尽可能接近PS2主机原生的效果。\nPython3 PyGame Numpy ModernGL PyGLM 01 初始化PyGame和ModernGL 第一步先初始化PyGame，设置窗口大小为640x480，FPS为60。开启OpenGL渲染模式，OpenGL的版本号设置为3.3。\n1 2 3 4 5 6 7 8 9 import pygame as pg pg.init() pg.display.gl_set_attribute(pg.GL_CONTEXT_MAJOR_VERSION, 3) pg.display.gl_set_attribute(pg.GL_CONTEXT_MINOR_VERSION, 3) pg.display.gl_set_attribute(pg.GL_CONTEXT_PROFILE_MASK, pg.GL_CONTEXT_PROFILE_CORE) pg.display.set_mode((640, 480), flags=pg.OPENGL | pg.DOUBLEBUF) self.clock = pg.time.Clock() self.clock.tick(60) 接着初始化ModernGL，非常简单，只要创建一个context，开启深度测试和面剔除。\n1 2 3 4 import moderngl as mgl self.ctx = mgl.create_context() self.ctx.enable(flags=mgl.DEPTH_TEST | mgl.CULL_FACE) 02 获取顶点、纹理、法线等数据 这部分内容在上一篇解析PS2游戏存档3D图标有详细描述，就不展开了，这里只贴一下icon.sys的数据结构供参考。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct IconSys { char magic[4]; uint16 unknown; // ignore uint16 subtitle_line_break; uint16 unknown; // ignore uint32 bg_transparency; uint32 bg_color_upper_left[4]; uint32 bg_color_upper_right[4]; uint32 bg_color_lower_left[4]; uint32 bg_color_lower_right[4]; float32 light_pos1[4]; float32 light_pos2[4]; float32 light_pos3[4]; float32 light_color1[4]; float32 light_color2[4]; float32 light_color3[4]; float32 ambient[4]; char subtitle[68]; char icon_file_normal[64]; char icon_file_copy[64]; char icon_file_delete[64]; char zeros[512]; // ignore }; 03 坐标系统 这里以右手系统创建坐标系，但是原始的顶点是y轴颠倒的，如下图A。因此我们之后的工作将在转换后的图B坐标系下进行。 04 变换矩阵 观察矩阵 上图B中，摄像机位置在z轴的负延伸方向，我们稍稍向y轴负方向移动一小段距离，这样可以使视线不是对着图标的脚部，而是稍稍靠上一点，因此将摄像机位置坐标设为(0, -2, -10)。因为要将y轴颠倒，可以直接将摄像机向上的方向设置为y轴的负方向。这样一来lookAt矩阵创建如下：\n1 2 3 self.position = glm.vec3(0, -2, -10) self.up = glm.vec3(0, -1, 0) self.view = glm.lookAt(self.position, glm.vec3(0, -2, 0), self.up) 投影矩阵 投影矩阵可以用如下公式获得\n1 self.proj = glm.perspective(glm.radians(50), window_width / window_height, 0.1, 100) 模型矩阵 创建模型矩阵的目的是控制模型对象在3D空间中的位置变化，在这里模型对象需要在空间里绕着y轴做360度的旋转。\n1 2 3 4 5 6 # 初始化模型矩阵 self.m_model = glm.mat4() # 使模型绕y轴旋转，转过的角度为经过的时间。 # 初始化的180度是为了让模型在开始的时候背对着画面，更接近PS2主机的行为 m_model = glm.rotate(self.m_model, glm.radians(180) + animation_time / 2, glm.vec3(0, 1, 0)) 05 创建着色器 这里一共需要创建四个着色器\n背景顶点着色器 背景片段着色器 Icon顶点着色器 Icon片段着色器 背景着色器 背景着色器比较简单，只要创建一个覆盖整个坐标系的矩形，并且设置在离摄像机最远的那个坐标平面上即可。参考上面的图B，这个平面应该是z轴的0.9999。这个矩形的四个顶点的坐标分别为(-1, 1), (-1, -1), (1, -1), (1, 1)，对应的颜色在icon.sys中可以解析出来。根据这四个顶点和颜色，就可以构建背景VBO及VAO，这里不做过多描述。\n1 2 3 4 5 6 7 8 9 10 11 12 // bg.vert #version 330 core in vec2 vertexPos; in vec4 vertexColor; out vec3 fragColor0; void main() { fragColor0 = vertexColor.rgb; gl_Position = vec4(vertexPos.xy, 0.9999, 1.0); } 1 2 3 4 5 6 7 8 9 10 11 12 // bg.frag #version 330 core in vec3 fragColor0; out vec4 fragColor; uniform float alpha0; void main() { fragColor = vec4(fragColor0, alpha0); } Icon着色器 Icon着色器会比较复杂，我们先尝试着把Icon顶点渲染出来。还记得每个图标有多个形状吗？形状与动画相关，我们现在只取其中的一个形状组成VBO和VAO。\n1 2 3 4 5 6 7 8 9 10 11 12 // icon.vert #version 330 core in vec4 vertexPos; uniform mat4 proj; uniform mat4 view; uniform mat4 model; void main() { gl_Position = proj * view * model * vec4(vertexPos.xyz, 1); } 1 2 3 4 5 6 7 8 // icon.frag #version 330 core out vec4 fragColor; void main() { fragColor = vec4(0, 0, 0, 1); } 以下是运行代码后的效果：\n添加纹理 在上面的基础上，引入纹理坐标和纹理数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // icon.vert #version 330 core in vec4 vertexPos; in vec2 texCoord; in vec4 vertexColor; out vec4 fragColor0; out vec2 uv0; uniform mat4 proj; uniform mat4 view; uniform mat4 model; void main() { uv0 = texCoord; fragColor0 = vertexColor; gl_Position = proj * view * model * vec4(vertexPos.xyz, 1); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // icon.frag #version 330 core in vec2 uv0; in vec4 fragColor0; out vec4 fragColor; uniform sampler2D texture0; void main() { float alpha = fragColor0.a; vec3 color = fragColor0.rgb * texture(texture0, uv0).rgb; fragColor = vec4(color, alpha); } 添加光照 在上面的基础上，引入光源，环境光以及法线数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // icon.vert #version 330 core in vec4 vertexPos; in vec2 texCoord; in vec4 vertexColor; in vec4 normal; out vec4 fragColor0; out vec2 uv0; out vec3 normal0; out vec3 fragPos0; uniform mat4 proj; uniform mat4 view; uniform mat4 model; void main() { uv0 = texCoord; fragColor0 = vertexColor; normal0 = mat3(model) * normalize(normal.xyz); gl_Position = proj * view * model * vec4(vertexPos.xyz, 1); fragPos0 = gl_Position.xyz; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // icon.frag #version 330 core #define MAX_NUM_TOTAL_LIGHTS 3 in vec2 uv0; in vec4 fragColor0; in vec3 normal0; in vec3 fragPos0; out vec4 fragColor; struct Light { vec4 pos; vec4 color; }; uniform sampler2D texture0; uniform vec4 ambient; uniform Light lights[MAX_NUM_TOTAL_LIGHTS]; void main() { vec3 normal = normalize(normal0); float alpha = fragColor0.a; vec3 color = fragColor0.rgb * texture(texture0, uv0).rgb; vec3 diffuse = vec3(0.0, 0.0, 0.0); for (int i = 0; i \u0026lt; MAX_NUM_TOTAL_LIGHTS; i++) { vec3 lightDir = normalize(lights[i].pos.xyz - fragPos0); float diff = max(dot(lightDir, normal), 0.0); diffuse += diff * lights[i].color.rgb; } color = (ambient.rgb + diffuse) * color; fragColor = vec4(color, alpha); } 动画效果 动画效果是让着色器按照时间渲染不同形状的顶点数据。我们可以设计一个计时器和一个计数器，以确定当前时间应该渲染哪个形状的顶点。\nframe_length 完成动画效果需要的实际帧数，实际帧率等于60FPS animation_time 动画运行时间 anim_speed 动画播放速度 frame_length / animation_shapes 一个形状包含多少帧 1 2 3 4 animation_time = time.time() - self.start_time curr_frame = int(animation_time * self.window.fps * self.icon.anim_speed) % self.icon.frame_length curr_shape = int(curr_frame // (self.icon.frame_length / self.icon.animation_shapes)) 使动画平滑过渡 使动画平滑过渡需要使用着色器的顶点插值技术。我们在发送着色器顶点的时候，将当前形状和下一个形状的顶点数据同时发送。这样再根据时间因子，着色器会自动计算两个形状之间的顶点。\ntween_factor 计算当前时间戳在整个形状中所占帧的百分比 1 2 curr_frame_in_shape = curr_frame % frames_in_shape / frames_in_shape tween_factor = glm.float32(curr_frame_in_shape) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // icon.vert #version 330 core in vec4 vertexPos; in vec2 texCoord; in vec4 vertexColor; in vec4 nextVertexPos; in vec4 normal; out vec4 fragColor0; out vec2 uv0; out vec3 normal0; out vec3 fragPos0; uniform mat4 proj; uniform mat4 view; uniform mat4 model; uniform float tweenFactor; void main() { uv0 = texCoord; fragColor0 = vertexColor; normal0 = mat3(model) * normalize(normal.xyz); vec4 basePos = vec4(mix(vertexPos.xyz, nextVertexPos.xyz, tweenFactor), 1.0); gl_Position = proj * view * model * basePos; fragPos0 = gl_Position.xyz; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // icon.frag #version 330 core #define MAX_NUM_TOTAL_LIGHTS 3 in vec2 uv0; in vec4 fragColor0; in vec3 normal0; in vec3 fragPos0; out vec4 fragColor; struct Light { vec4 pos; vec4 color; }; uniform sampler2D texture0; uniform vec4 ambient; uniform Light lights[MAX_NUM_TOTAL_LIGHTS]; void main() { vec3 normal = normalize(normal0); float alpha = fragColor0.a; vec3 color = fragColor0.rgb * texture(texture0, uv0).rgb; vec3 diffuse = vec3(0.0, 0.0, 0.0); for (int i = 0; i \u0026lt; MAX_NUM_TOTAL_LIGHTS; i++) { vec3 lightDir = normalize(lights[i].pos.xyz - fragPos0); float diff = max(dot(lightDir, normal), 0.0); diffuse += diff * lights[i].color.rgb; } color = (ambient.rgb + diffuse) * color; fragColor = vec4(color, alpha); } 最终效果：\n06 尾声 所有代码均可在 https://github.com/caol64/ps2mc-browser 下载到。在我的第一篇文章中，我也提到了这个系列的创作初衷：为了纪念逝去的青春，以及对技术永不磨灭的热情。在此收尾，也算还了年少时的一个梦想。\n07 参考文献 gothi - icon.sys format Martin Akesson - PS2 Icon Format v0.5 Florian Märkl - mymcplus Ross Ridge - PlayStation 2 Memory Card File System ","permalink":"https://babyno.top/posts/2023/10/rendering-ps2-3d-icon/","summary":"经过前面一系列文章的铺垫，PS2存档3D图标的文件已经全部解析完毕。本篇开始将介绍使用如下工具将3D图标渲染出来，并尽可能接近PS2主机原生","title":"使用Python和OpenGL渲染PS2存档3D图标"},{"content":" 看到这个图片，对于熟悉PS2的老玩家来说应该不会陌生。它是PS2记忆卡管理界面中的游戏存档3D图标。本篇文章我们将介绍如何从存档文件里解析出这个活动的小人。\n01 解析目标 A：我们能从存档文件中解析到什么？\n图标模型的所有顶点、法线 图标模型的动作帧 光照 纹理及纹理坐标 背景颜色及透明度 B：我们需要做什么？\n编写着色器渲染背景和图标 将图标模型的动作帧组成动画 构建模型矩阵、视图矩阵、透视矩阵，使显示接近PS2原生效果 完成整个功能估计需要两篇文章，本篇主要介绍A。\n02 解析icon.sys 上一篇我们介绍了如何导出游戏的存档文件，事实上每个存档里都会有一个icon.sys的文件，这个可以看作图标的配置文件。icon.sys是一个固定大小（964字节）的文件，其结构如下：\noffset length description 0 byte[4] magic：PS2D 4 uint16 0 6 uint16 游戏标题换行符所在位置，注1 8 uint32 0 12 uint32 bg_transparency，背景透明度，0-255 16 uint32[4] bg_color，背景左上角颜色（RGB-，0-255） 32 uint32[4] bg_color，背景右上角颜色（RGB-，0-255） 48 uint32[4] bg_color，背景左下角颜色（RGB-，0-255） 64 uint32[4] bg_color，背景右下角颜色（RGB-，0-255） 80 uint32[4] light_pos1，光源1（XYZ-，0-1） 96 uint32[4] light_pos2，光源2（XYZ-，0-1） 112 uint32[4] light_pos3，光源3（XYZ-，0-1） 128 uint32[4] light_color1，光源1颜色（RGB-，0-1） 144 uint32[4] light_color2，光源2颜色（RGB-，0-1） 160 uint32[4] light_color3，光源3颜色（RGB-，0-1） 176 uint32[4] ambient，环境光（RGB-，0-1） 192 byte[68] sub_title，游戏标题（空字符结尾, S-JIS编码） 260 byte[64] icon_file_normal，普通图标文件名（空字符结尾），注2 324 byte[64] icon_file_copy，拷贝图标文件名（空字符结尾），注2 388 byte[64] icon_file_delete，删除图标文件名（空字符结尾），注2 452 byte[512] 全0 注1：游戏标题sub_title显示为2行，该值即为在标题的第几个字节换行，如图：\n注2：每个游戏存档可以对应3个图标icon文件，分别在不同场景显示。\n可以看到icon.sys文件里主要提供了背景、光照等数据，另外一个比较重要的部分是3d图标所在的文件名。\n03 解析icon文件 不像icon.sys文件，每个游戏的icon文件是不确定的，大小不确定，数量也不确定，但至少会有1个。有的游戏拷贝图标和删除图标与普通图标共用一个图标。\n3.1 文件结构 名称 说明 Icon头 固定大小，20个字节 顶点段 保存图标模型的所有顶点和法线数据 动画段 保存图标模型动画帧信息 纹理段 保存图标模型纹理 3.2 Icon头 Icon头存储了我们解码不同数据段所需的所有重要信息，其中包括：\n“顶点段”中包含的顶点数量以及动画形状的数量 纹理数据是否经过压缩 在图标文件中，Icon头总是位于偏移量 0 处。以下是Icon头结构：\nOffset Length Description 0000 uint32 magic：0x010000 0004 uint32 animation_shapes，动画形状，注1 0008 uint32 tex_type，纹理类型，注2 0012 uint32 未知，固定值0x3F800000 0016 uint32 vertex_count，顶点数量，必定是3的倍数 注1：图标模型有几套不同的顶点数据，对应不同的动作，称之为“形状”。将不同的形状循环渲染，即可形成动画效果。\n注2：“纹理类型”这部分尚不明确，该值是4字节整形，我总结出来每个位相应的功能如下表，未必正确：\nmask Description 0001 未知 0010 未知 0100 图标文件中存在纹理数据，有些游戏（如ICO）没有纹理数据，图标全黑 1000 图标文件中的纹理数据是被压缩过的 3.3 顶点段 PS2 图标中的多边形总是由三个顶点形成的三角形组成。由于顶点是按一定规律排列的，因此只需按照规律读取顶点数据，就能轻松构建多边形。利用OpenGL或类似工具渲染这些数据，就能得到一个漂亮的图标线框。\n“顶点段”包含图标中所有顶点的数据。每个顶点数据包含一组顶点坐标、法线坐标、纹理坐标以及一组RGBA数据，因此，拥有m个顶点和 n个形状的“顶点段”数据结构如下：\n顶点坐标 每个顶点坐标占用8字节，结构如下：\nOffset Length Description 0000 int16 X坐标，使用时需除以4096 0002 int16 Y坐标，使用时需除以4096 0004 int16 Z坐标，使用时需除以4096 0006 uint16 未知 法线坐标 每个法线坐标与顶点坐标数据结构一致。\n纹理坐标 每个纹理坐标占用4字节，结构如下：\nOffset Length Description 0000 int16 U坐标，使用时需除以4096 0002 int16 V坐标，使用时需除以4096 顶点RGBA 每个顶点颜色占用4字节，结构如下：\nOffset Length Description 0000 uint8 R，0-255 0001 uint8 G，0-255 0002 uint8 B，0-255 0003 uint8 A，0-255 3.4 动画段 很遗憾关于“动画段”里的大部分内容，我还没完全搞懂含义。不过不用太在意，利用“顶点坐标插值”，仍然可以完成动画动作。\n以下是“动画段”的数据结构：\n“动画段”包含“动画头”和若干“动画帧”，每个“动画帧”包含若干“关键帧”。\n动画头 “动画头”结构如下：\nOffset Length Description 0000 uint32 magic：0x01 0004 uint32 frame length：“动画帧”完成一个循环所需的“播放帧”，根据这个值可以计算出每个“动画帧”对应的“播放帧”数量 0008 float32 anim speed：播放速度，作用未知 0012 uint32 play offset：起始播放帧，作用未知 0016 uint32 frame count：“动画段”一共有几个“动画帧”，一般一个“形状”对应一个“动画帧” 帧数据Frame Data “帧数据”直接位于“动画头”之后。\nOffset Type Description 0000 u32 Shape id 0004 u32 Number of keys 0008 u32 UNKNOWN 0012 u32 UNKNOWN 关键帧Frame Key Offset Type Description 0000 f32 Time 0004 f32 Value 3.5 纹理段 纹理是像素为128x128的图片，使用TIM图像格式进行编码。根据Icon头里的tex_type字段，纹理分为未压缩和压缩两种类型。\n未压缩纹理 未压缩纹理的像素格式为BGR555，其中B、G、R各占用5bit，总共15bit，占用2字节（1个bit冗余）。如图：\n1 2 3 4 High-order byte: Low-order byte: X B B B B B G G G G G R R R R R X = Don\u0026#39;t care, R = Red, G = Green, B = Blue 因此原始图片大小固定为128x128x2字节。如果需将它的像素格式转为RGB24，可以用如下方法：\n1 2 High-order byte: Middle-order byte: Low-order byte: R R R R R 0 0 0 G G G G G 0 0 0 B B B B B 0 0 0 将5bit的色彩值转为8bit时，需将低3位补0。经过上述转换，每像素字节数变为3字节。同理也可将格式转为RGBA32，每像素字节数变为4字节。\n压缩纹理 压缩纹理使用非常简单的RLE算法进行压缩。第一个u32是压缩纹理数据的大小。其后的数据始终为u16的rle_code和rle_data交替出现，直到结束。 rle_data有两个变量：data数量x和重复次数y。rle_code作为计数器存在，如果小于0xFF00，则x = 1，y = rle_code；如果大于等于0xFF00，则x = (0x10000 - rle_code)，y = 1。如下图。\n将压缩纹理解压后，再根据上一节的内容即可转换为RGB24或RGBA32的图片。\n04 结尾 至此为止图标的相关文件已经解析完毕了，万事俱备只欠东风，下一篇我们即将开始渲染模式，使用PyGame和ModernGL将渲染动画显示出来。\n05 参考资料 gothi - icon.sys format Martin Akesson - PS2 Icon Format v0.5 ","permalink":"https://babyno.top/posts/2023/10/parsing-ps2-3d-icon/","summary":"看到这个图片，对于熟悉PS2的老玩家来说应该不会陌生。它是PS2记忆卡管理界面中的游戏存档3D图标。本篇文章我们将介绍如何从存档文件里解析出","title":"解析PS2游戏存档3D图标"},{"content":"上一篇文章中我们解析了PS2存储卡的文件系统，这次直接实战，编写python代码导出指定的游戏存档。本篇文章完整代码可以访问：ps2mc-browser。\n01 解析SuperBlock SuperBlock结构如下，大小为340字节：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct SuperBlock { char magic[28]; char version[12]; uint16 page_size; uint16 pages_per_cluster; uint16 pages_per_block; uint16 unknown; // ignore uint32 clusters_per_card; uint32 alloc_offset; uint32 alloc_end; uint32 rootdir_cluster; uint32 backup_block1; // ignore uint32 backup_block2; // ignore uint32 unknown[2]; // ignore uint32 ifc_list[32]; uint32 bad_block_list[32]; // ignore byte card_type; byte card_flags; byte unknown; // ignore byte unknown; // ignore }; 使用struct.unpack()解包：\n1 struct.Struct(\u0026#34;\u0026lt;28s12sHHH2xLLLL4x4x8x128s128xbbxx\u0026#34;).unpack(byte_val) 得到page_size和pages_per_cluster。\n02 读取page和cluster 根据公式计算page和cluster大小：\n1 2 3 self.spare_size = (self.page_size // 128) * 4 # 备用区域字节数 self.raw_page_size = self.page_size + self.spare_size # 算上备用区域的page字节数 self.cluster_size = self.page_size * self.pages_per_cluster # 簇字节数 读取page和cluster，spare area里的内容是被舍弃掉的：\n1 2 3 4 5 6 7 8 9 10 def read_page(self, n): # n为page编号 offset = self.raw_page_size * n return self.byte_val[offset: offset + self.page_size] def read_cluster(self, n): # n为cluster编号 page_index = n * self.pages_per_cluster byte_buffer = bytearray() for i in range(self.pages_per_cluster): byte_buffer += self.read_page(page_index + i) return bytes(byte_buffer) 03 构建FAT矩阵 从上一篇文章知道FAT矩阵的构建方式如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __build_fat_matrix(self): # 从ifc_list构建间接FAT indirect_fat_matrix = self.__build_matrix(self.ifc_list) # 间接FAT是个一维数组 indirect_fat_matrix = indirect_fat_matrix.reshape(indirect_fat_matrix.size) # 排除掉0xFFFFFFFF这种未分配的 indirect_fat_matrix = [x for x in indirect_fat_matrix if x != Fat.UNALLOCATED] # 从间接FAT构建直接FAT fat_matrix = self.__build_matrix(indirect_fat_matrix) return fat_matrix def __build_matrix(self, cluster_list): # 初始化矩阵 matrix = np.zeros((len(cluster_list), self.fat_per_cluster), np.uint32) # 遍历cluster for index, v in enumerate(cluster_list): # 读出每个cluster的256个FAT cluster_value = self.read_cluster(v) cluster_value_unpacked = np.frombuffer(cluster_value, np.uint32) for index0, v0 in enumerate(cluster_value_unpacked): # 给矩阵赋值 matrix[index, index0] = v0 return matrix # 给出簇编号n，找到其对应的FAT的值 def get_fat_value(self, n): value = self.fat_matrix[(n // self.fat_per_cluster) % self.fat_per_cluster, n % self.fat_per_cluster] # 最高位为8代表正常使用的簇，其它值代表簇未分配，最高位为8时，取低31位的整形值 return value ^ Fat.ALLOCATED_BIT if value \u0026amp; Fat.ALLOCATED_BIT \u0026gt; 0 else value 04 条目数据结构 条目是所有文件和目录的元数据，条目的数据结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct Entry { uint16 mode; uint16 unknown; // ignore uint32 length; char created[8]; uint32 cluster; uint32 dir_entry; // ignore char modified[8]; uint32 attr; // ignore char padding[28]; // ignore char name[32]; char padding[416]; // ignore }; 使用struct.unpack()解包：\n1 struct.Struct(\u0026#34;\u0026lt;H2xL8sL4x8s4x28x32s416x\u0026#34;).unpack(byte_val) 每个条目的大小为512字节，条目里最重要的字段是cluster，标识了该条目对应的文件或目录的簇编号。如果本条目是目录，则对应的簇编号是“条目簇”；如果本条目是文件，则对应的簇编号是“文件簇”。另一个重要字段是length，如果本条目是目录，则对应的是目录下的条目数；如果本条目是文件，则对应的是文件的字节数。\n05 解析“条目簇”和“数据簇” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 读取条目，条目是512字节，一个簇可以包含多个条目 def read_entry_cluster(self, cluster_offset): cluster_value = self.read_cluster(cluster_offset + self.alloc_offset) return Entry.build(cluster_value) # 读取数据，要从第一个簇开始读取到文件结束 def read_data_cluster(self, entry): byte_buffer = bytearray() chain_start = entry.cluster bytes_read = 0 while chain_start != Fat.CHAIN_END: to_read = min(entry.length - bytes_read, self.cluster_size) byte_buffer += self.read_cluster(chain_start + self.alloc_offset)[:to_read] bytes_read += to_read chain_start = self.get_fat_value(chain_start) return bytes(byte_buffer) def build(byte_val): entry_count = len(byte_val) // Entry.__size entries = [] for i in range(entry_count): entries.append(Entry(byte_val[i * Entry.__size: i * Entry.__size + Entry.__size])) return entries 06 读取存储卡中的所有文件 上一篇文章说过，根目录没有条目，它的首个“条目簇”在超级块的rootdir_cluster中，它的“包含条目数”在.这个条目中。\n要读取存储卡中的所有文件，第一步是解析根目录下所有条目，再解析条目下所有文件。因此只要循环调用以下方法：\n1 2 3 4 5 6 7 8 9 10 def find_sub_entries(self, parent_entry): chain_start = parent_entry.cluster sub_entries = [] while chain_start != Fat.CHAIN_END: entries = self.read_entry_cluster(chain_start) for e in entries: if len(sub_entries) \u0026lt; parent_entry.length: sub_entries.append(e.unpack()) chain_start = self.get_fat_value(chain_start) return [x for x in sub_entries if not x.name.startswith(\u0026#39;.\u0026#39;)] 结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 BISCPS-15119sv01 GameData BISCPS-15119sv01 icon00.ico icon.sys BISCPS-15116sv01 GameData BISCPS-15116sv01 icon00.ico icon.sys BASLUS-21441DBZT2 icon.sys dbzsn.ico BASLUS-21441DBZT2 ... 07 导出游戏存档 既然所有文件条目都已经读取出来了，我们只要写个方法，根据输入的游戏名称，即可导出目录下的所有文件。\n1 2 3 4 5 6 7 8 9 def export(self, name, dest): dir_path = dest + os.sep + name if not os.path.exists(dir_path): os.mkdir(dir_path) entries = self.lookup_entry_by_name(name) for e in entries: if e.is_file(): with open(dir_path + os.sep + e.name, \u0026#39;wb\u0026#39;) as f: f.write(self.ps2mc.read_data_cluster(e)) 08 结尾 至此，我们已经可以把一个游戏的存档从存储卡中导出来了。如果你有python运行环境，可以直接运行文章一开始提供的github链接里的代码。\n下一篇我们将分析一下每个存档文件里的icon.sys和xxx.ico文件，这两个文件是存档3d特效的数据文件。\n09 参考文献 Ross Ridge - PlayStation 2 Memory Card File System Florian Märkl - mymcplus ","permalink":"https://babyno.top/posts/2023/09/exporting-file-from-ps2-memcard/","summary":"上一篇文章中我们解析了PS2存储卡的文件系统，这次直接实战，编写python代码导出指定的游戏存档。本篇文章完整代码可以访问：ps2mc-b","title":"从PS2记忆卡中导出存档文件"},{"content":" 01 前言 作为一个80后的游戏老玩家，PS2游戏机在我心中一直有着特殊的地位。时至今日，已经过去了20多年，然而，最近我因为模拟器的缘故重新接触到了它。在重温了一段时间游戏后，我突发奇想，能否通过现在的知识来回忆年少时的自己？于是，我开始了这一系列文章的创作，从分析PS2存储卡的文件系统开始，逐步深入的解析其文件存储机制及每个游戏的存档文件。我的目标是，最终通过Python和OpenGL，模拟出游戏存档中经典的3D人物旋转效果，以此来纪念这个曾经陪伴我度过青春时光的经典游戏机。\n这是系列的第一篇作品，解析PS2存储卡的文件系统。\n02 词汇表 存储卡 指PS2实体机使用的专用记忆卡介质，使用时插在主机上，与主机是相互独立的两个设备。 NAND闪存 PS2存储卡使用的内部芯片，一种非易失性存储设备。 存储卡文件 指PS2模拟器使用的存储卡镜像文件，保存在模拟器所在的电脑磁盘上，以.ps2为后缀。是我们这篇文章解析的目标。 SuperBlock 超级块，位于文件系统开头的固定部分，由存储卡格式化时写入，不可更改，记录了存储卡的基本硬件指标。 page 页，文件系统的最小读写单元，页的大小定义于超级块中。 cluster 簇，文件系统中的最小分配单位，要保存一个文件至少需要一个簇。簇的大小定义于超级块中。 block 块，文件系统的最小擦除单位，块的大小定义于超级块中。 擦除 闪存初始化时页中的每一个bit都为1，写操作可以将bit置为0，但无法恢复为1。擦除是将bit恢复成1的唯一途径，但缺点是擦除以块为单位，哪怕只是修改一位数据，也得先擦除一个块，然后再用写操作把块的每一页恢复。这也是PS2游戏存档时普遍较慢的原因。 FAT 文件分配表，与FAT16和FAT32文件系统中的文件分配表类似。由于文件会保存在多个簇上，而簇可以是不连续的，为了确保在存取文件时能够检索到所有连续或不连续的簇地址，文件分配表采用了“簇链”这种链表的记录方式。 ifc indirect FAT cluster间接FAT簇，是一个簇，其中保存有存储卡上FAT簇的列表。 ifc_list ifc的数组，定义于超级块中。通过它可以找到ifc簇。 ECC 纠错码（Error Correction Code），闪存特性，写入page时需要对每一页进行纠错码计算，并写入spare area中。 spare area 备用区域，为每一个页保存ECC的一段空间。 entry 条目，存储卡上保存的文件或目录的基本信息单元，比如：文件（目录）名、大小、第一个簇编号等。 03 文件系统结构 注：这里用标准的8M存储卡举例。\n3.1 数据结构 从超级块中可得知页的大小是512字节，簇的大小是2个页。spare area可以根据公式(page_len / 128) * 4得到，是16字节，则文件系统基本数据结构如图：\n3.2 逻辑结构 了解了最基本的数据结构，接下来我们划分一下存储卡的逻辑结构。如下图，一块存储卡大致能分为以下几个逻辑区块。（黑白部分本文不涉及，可以忽略。）注意：组成逻辑区块的最小单位是簇。\n超级块 位于整个文件开头（也就是第一个簇）的前340个字节，这是文件系统中唯一具有固定位置的部分。下图示意了一个存储卡文件的超级块。\n注：PS2存储卡的字节序是小端序Little-endian。\nOffset Name Length Default Description 0 magic byte[28] - 固定字符串\u0026quot;Sony PS2 Memory Card Format\u0026quot;， 表明该卡已成功初始化 28 version byte[12] 1.X.0.0 版本号 40 page_len uint16 512 page的大小(以字节为单位) 42 pages_per_cluster uint16 2 簇中的页数 44 pages_per_block uint16 16 块中的页数 46 - uint16 0xFF00 未知 48 clusters_per_card uint32 8192 卡的总大小(以簇为单位) 52 alloc_offset uint32 41 第一个可分配簇 56 alloc_end uint32 8135 最后一个可分配簇 60 rootdir_cluster uint32 0 根目录的第一个簇，相对于alloc_offset 64 backup_block1 uint32 1023 本文无用 68 backup_block2 uint32 1022 本文无用 80 ifc_list uint32[32] 8 间接 FAT 簇列表，在标准 8M 卡上只有一个间接 FAT 簇 208 bad_block_list uint32[32] -1 本文无用 336 card_type byte 2 必须是2，说明这是一张PS2存储卡 337 card_flags byte 0x52 存储卡的物理特性 字段page_len、pages_per_cluster、pages_per_block和cluster_per_card定义文件系统的基本几何结构。可以使用ifc_list访问FAT，rootdir_cluster给出根目录的第一个簇。FAT和目录项中的簇偏移量都与alloc_offset相关。\nFAT 文件分配表是一个链表，当你找到一个文件的起始簇时，你想象有两个线程，线程x用来读取这个簇里的内容（即数据），线程y去FAT里寻找下一个簇，交由x读取，然后不断循环，当然两个线程不是必须的。这里引用一张图说明一下这种工作方式：\n已知文件A，起始簇是8 线程x去簇8读取第一块数据A0 线程y去FAT查找8的下一个簇是13 线程x继续读取簇13的数据A1 线程y去FAT查找13的下一个簇是7 不断循环 图片来源：https://www.slideserve.com/yahto/file-system-implementation\n直接FAT 由前文可以得知，直接FAT和间接FAT都是保存在簇里的。簇里的数据必须有一个良好的结构，才能使我们简单的解析成FAT链表。FAT在簇里的结构可以想象成长这样：\n这是一个矩阵M，行定义为FAT所在的簇，列定义为每个FAT簇里的数据。每个FAT簇，保存的都是4字节32位的整形数组，数量为1024 / 4 = 256个，因此矩阵有256列。FAT一共有多少个簇呢？这点可以在间接FAT的簇中解析出来，我们之后再讲。在这里FAT一共占据了32个簇，因此矩阵有32行。\nM矩阵的大小为32 * 256 = 8192，意味着这个FAT可以管理8192个簇。假设现在要找簇n在矩阵中的位置row和column，可以根据简单的计算得出：\n1 2 row = (n // 256) % 256 column = n % 256 既然已经计算出了位置，那就可以取到对应的值了，没错，这个值?就是下一个簇。通过不断循环，直到取到的值为0xFFFFFFFF，表示簇链到结尾了，不需要再查找了。\n注：FAT表里储存的值为32位，最高位为8代表正常使用的簇，其它值代表簇未分配，最高位为8时，取低31位的整形值。值为0xFFFFFFFF代表已是簇链末尾。\n间接FAT 前文留了一个问题，为什么FAT占有了32个簇？\n在超级块中有一个字段ifc_list，是一个4字节32位的整形数组，再想象一下上面出现的矩阵。ifc_list是一个只有一行的矩阵，虽然它有32个元素，但只有第一个有值，其值8即间接FAT簇ifc。将簇8的内容按照上文的方法解析出来，再形成一个矩阵，行是ifc_list的个数，理论上是32，但由于只有1个元素，因此这个矩阵的行也为1。矩阵的列依然是256。解析其中的值，可以得到FAT所在的簇为9到40，即32个。\n可分配簇 是一个范围，从alloc_offset开始到alloc_end结束。除去超级块、FAT、保留簇等的位置，所有的游戏存档都位于可分配簇内。\n04 文件和目录 接着我们要研究下可分配簇里，每个簇都保存了些什么东西？简单来说，可分配簇里只有两种簇：“条目簇”和“数据簇”。保存条目的簇称为“条目簇”，保存数据的簇称为“数据簇”。\n4.1 条目 每个目录或文件都有一个“条目”，可以看作是元数据，保存有文件名、大小、创建和修改时间等属性。每个“条目”的长度为 512 字节，因此每个 1024 簇中只能容纳两个“条目”。“条目簇”不会保存文件数据，即使“条目簇”里只有一个“条目”。\n除了根目录没有root这个“条目”外，每个目录都有以自己的目录名命名的“条目”，每个文件也有以自己的文件名命名的“条目”，“条目”的结构如下表：\nOffset Name Length Description 0 mode uint16 标识该文件的属性 4 length uint32 如果是文件，以字节为单位；如果是目录，以项为单位。 8 created byte[8] 创建时间 16 cluster uint32 条目对应的第一个簇，是相对于alloc_offset的相对值。 20 dir_entry uint32 无用 24 modified byte[8] 修改时间 32 attr uint32 用户属性 36 name byte[32] 文件名，x00以后的需截断 mode字段请参考：https://www.ps2savetools.com/ps2memcardformat.html 。是一个4字节整形数，每个字节用对应的掩码比对，即可识别“条目”对应的文件类型。比如：0x8427代表一个目录，0x8497代表一个文件。 cluster字段代表了“条目”的第一个簇。如果本条目是目录，则这个簇指向的是当前目录的下一个“条目簇”；如果本条目是文件，则这个簇指向的是文件的第一个“数据簇”。 每个目录下的第一个“条目簇”一定是名为.和..的两个目录，这两个目录项代表当前目录和父目录，就像在Unix中一样。 目录下有几个“条目”以及文件有几个字节都是由length字段决定的，当你按照“簇链”读取文件的时候，需要自己记录最后一个簇的哪里是最后一个字节。 05 结尾 至此，相信大家对一个ps2存储文件有了大致认识了吧。有兴趣的可以自己写一个程序解析下了。稍后我也会创建一个项目，附上本篇文章涉及的源代码。\n下一篇文章我们将开始把游戏存档从存储卡里导出来，看看每个游戏存档都有哪些文件。\n06 参考文献 本文主要参考了如下文章，在此表示感谢🙏：\nRoss Ridge - PlayStation 2 Memory Card File System ","permalink":"https://babyno.top/posts/2023/09/parsing-ps2-memcard-file-system/","summary":"01 前言 作为一个80后的游戏老玩家，PS2游戏机在我心中一直有着特殊的地位。时至今日，已经过去了20多年，然而，最近我因为模拟器的缘故重新接触","title":"解析PS2记忆卡文件系统"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nThe following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Inline Code This is Inline Code\nOnly pre This is pre text Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with backticks and language specified 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Sample article showcasing basic Markdown syntax and formatting for HTML elements.\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nmermaid test sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eBob: Hi Bob Bob-\u003e\u003eAlice: Hi Alice The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://babyno.top/posts/2019/03/hello-world/","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","title":"Hello World"}]